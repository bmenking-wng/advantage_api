<?php
/**
 * CustomerCreateRequest
 *
 * PHP version 5
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Advantage.Rest.Services
 *
 * No description provided (generated by Advantage Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Advantage Codegen version: 2.4.20
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Advantage\Client\Model;

use \ArrayAccess;
use \Advantage\Client\ObjectSerializer;

/**
 * CustomerCreateRequest Class Doc Comment
 *
 * @category Class
 * @description Information needed to request the creation of a customer.
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CustomerCreateRequest implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'CustomerCreateRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'address' => '\Advantage\Client\Model\CustomerAddressUpdateRequest',
        'address_standardization_setting' => 'string',
        'promote' => 'string',
        'promote_by_partners' => 'string',
        'birth_date' => '\DateTime',
        'sex_code' => 'string',
        'customer_type' => 'string',
        'change_source' => 'string',
        'demographics' => '\Advantage\Client\Model\DemographicValue[]',
        'block_duplicate_match_level_code' => 'string',
        'force_create' => 'bool',
        'is_account' => 'bool',
        'block_duplicate_match_with_activity' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'address' => null,
        'address_standardization_setting' => null,
        'promote' => null,
        'promote_by_partners' => null,
        'birth_date' => 'date-time',
        'sex_code' => null,
        'customer_type' => null,
        'change_source' => null,
        'demographics' => null,
        'block_duplicate_match_level_code' => null,
        'force_create' => null,
        'is_account' => null,
        'block_duplicate_match_with_activity' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'address' => 'Address',
        'address_standardization_setting' => 'AddressStandardizationSetting',
        'promote' => 'Promote',
        'promote_by_partners' => 'PromoteByPartners',
        'birth_date' => 'BirthDate',
        'sex_code' => 'SexCode',
        'customer_type' => 'CustomerType',
        'change_source' => 'ChangeSource',
        'demographics' => 'Demographics',
        'block_duplicate_match_level_code' => 'BlockDuplicateMatchLevelCode',
        'force_create' => 'ForceCreate',
        'is_account' => 'IsAccount',
        'block_duplicate_match_with_activity' => 'BlockDuplicateMatchWithActivity'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'address' => 'setAddress',
        'address_standardization_setting' => 'setAddressStandardizationSetting',
        'promote' => 'setPromote',
        'promote_by_partners' => 'setPromoteByPartners',
        'birth_date' => 'setBirthDate',
        'sex_code' => 'setSexCode',
        'customer_type' => 'setCustomerType',
        'change_source' => 'setChangeSource',
        'demographics' => 'setDemographics',
        'block_duplicate_match_level_code' => 'setBlockDuplicateMatchLevelCode',
        'force_create' => 'setForceCreate',
        'is_account' => 'setIsAccount',
        'block_duplicate_match_with_activity' => 'setBlockDuplicateMatchWithActivity'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'address' => 'getAddress',
        'address_standardization_setting' => 'getAddressStandardizationSetting',
        'promote' => 'getPromote',
        'promote_by_partners' => 'getPromoteByPartners',
        'birth_date' => 'getBirthDate',
        'sex_code' => 'getSexCode',
        'customer_type' => 'getCustomerType',
        'change_source' => 'getChangeSource',
        'demographics' => 'getDemographics',
        'block_duplicate_match_level_code' => 'getBlockDuplicateMatchLevelCode',
        'force_create' => 'getForceCreate',
        'is_account' => 'getIsAccount',
        'block_duplicate_match_with_activity' => 'getBlockDuplicateMatchWithActivity'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const ADDRESS_STANDARDIZATION_SETTING_USE_ADVANTAGE_SYSTEM_OPTION = 'UseAdvantageSystemOption';
    const ADDRESS_STANDARDIZATION_SETTING_OFF = 'Off';
    const ADDRESS_STANDARDIZATION_SETTING_ACCEPT = 'Accept';
    const ADDRESS_STANDARDIZATION_SETTING_MARK_EXEMPT = 'MarkExempt';
    const ADDRESS_STANDARDIZATION_SETTING_MARK_FOR_REVIEW = 'MarkForReview';
    const ADDRESS_STANDARDIZATION_SETTING_MARK_INVALID = 'MarkInvalid';
    const ADDRESS_STANDARDIZATION_SETTING_REJECT = 'Reject';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAddressStandardizationSettingAllowableValues()
    {
        return [
            self::ADDRESS_STANDARDIZATION_SETTING_USE_ADVANTAGE_SYSTEM_OPTION,
            self::ADDRESS_STANDARDIZATION_SETTING_OFF,
            self::ADDRESS_STANDARDIZATION_SETTING_ACCEPT,
            self::ADDRESS_STANDARDIZATION_SETTING_MARK_EXEMPT,
            self::ADDRESS_STANDARDIZATION_SETTING_MARK_FOR_REVIEW,
            self::ADDRESS_STANDARDIZATION_SETTING_MARK_INVALID,
            self::ADDRESS_STANDARDIZATION_SETTING_REJECT,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['address'] = isset($data['address']) ? $data['address'] : null;
        $this->container['address_standardization_setting'] = isset($data['address_standardization_setting']) ? $data['address_standardization_setting'] : null;
        $this->container['promote'] = isset($data['promote']) ? $data['promote'] : null;
        $this->container['promote_by_partners'] = isset($data['promote_by_partners']) ? $data['promote_by_partners'] : null;
        $this->container['birth_date'] = isset($data['birth_date']) ? $data['birth_date'] : null;
        $this->container['sex_code'] = isset($data['sex_code']) ? $data['sex_code'] : null;
        $this->container['customer_type'] = isset($data['customer_type']) ? $data['customer_type'] : null;
        $this->container['change_source'] = isset($data['change_source']) ? $data['change_source'] : null;
        $this->container['demographics'] = isset($data['demographics']) ? $data['demographics'] : null;
        $this->container['block_duplicate_match_level_code'] = isset($data['block_duplicate_match_level_code']) ? $data['block_duplicate_match_level_code'] : null;
        $this->container['force_create'] = isset($data['force_create']) ? $data['force_create'] : null;
        $this->container['is_account'] = isset($data['is_account']) ? $data['is_account'] : null;
        $this->container['block_duplicate_match_with_activity'] = isset($data['block_duplicate_match_with_activity']) ? $data['block_duplicate_match_with_activity'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getAddressStandardizationSettingAllowableValues();
        if (!is_null($this->container['address_standardization_setting']) && !in_array($this->container['address_standardization_setting'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'address_standardization_setting', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets address
     *
     * @return \Advantage\Client\Model\CustomerAddressUpdateRequest
     */
    public function getAddress()
    {
        return $this->container['address'];
    }

    /**
     * Sets address
     *
     * @param \Advantage\Client\Model\CustomerAddressUpdateRequest $address The information needed for the customer's address.
     *
     * @return $this
     */
    public function setAddress($address)
    {
        $this->container['address'] = $address;

        return $this;
    }

    /**
     * Gets address_standardization_setting
     *
     * @return string
     */
    public function getAddressStandardizationSetting()
    {
        return $this->container['address_standardization_setting'];
    }

    /**
     * Sets address_standardization_setting
     *
     * @param string $address_standardization_setting The standardization settings for validating the address.
     *
     * @return $this
     */
    public function setAddressStandardizationSetting($address_standardization_setting)
    {
        $allowedValues = $this->getAddressStandardizationSettingAllowableValues();
        if (!is_null($address_standardization_setting) && !in_array($address_standardization_setting, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'address_standardization_setting', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['address_standardization_setting'] = $address_standardization_setting;

        return $this;
    }

    /**
     * Gets promote
     *
     * @return string
     */
    public function getPromote()
    {
        return $this->container['promote'];
    }

    /**
     * Sets promote
     *
     * @param string $promote Specifies whether or not the customer has opted to receive promotions.  If this isn't set, a Y/N value will be extrapolated based on the Address.PromoteByX settings.
     *
     * @return $this
     */
    public function setPromote($promote)
    {
        $this->container['promote'] = $promote;

        return $this;
    }

    /**
     * Gets promote_by_partners
     *
     * @return string
     */
    public function getPromoteByPartners()
    {
        return $this->container['promote_by_partners'];
    }

    /**
     * Sets promote_by_partners
     *
     * @param string $promote_by_partners Specifies whether or not the customer has opted to receive promotions from third-parties.
     *
     * @return $this
     */
    public function setPromoteByPartners($promote_by_partners)
    {
        $this->container['promote_by_partners'] = $promote_by_partners;

        return $this;
    }

    /**
     * Gets birth_date
     *
     * @return \DateTime
     */
    public function getBirthDate()
    {
        return $this->container['birth_date'];
    }

    /**
     * Sets birth_date
     *
     * @param \DateTime $birth_date The customer's date of birth
     *
     * @return $this
     */
    public function setBirthDate($birth_date)
    {
        $this->container['birth_date'] = $birth_date;

        return $this;
    }

    /**
     * Gets sex_code
     *
     * @return string
     */
    public function getSexCode()
    {
        return $this->container['sex_code'];
    }

    /**
     * Sets sex_code
     *
     * @param string $sex_code The customer's gender
     *
     * @return $this
     */
    public function setSexCode($sex_code)
    {
        $this->container['sex_code'] = $sex_code;

        return $this;
    }

    /**
     * Gets customer_type
     *
     * @return string
     */
    public function getCustomerType()
    {
        return $this->container['customer_type'];
    }

    /**
     * Sets customer_type
     *
     * @param string $customer_type The type code for the customer
     *
     * @return $this
     */
    public function setCustomerType($customer_type)
    {
        $this->container['customer_type'] = $customer_type;

        return $this;
    }

    /**
     * Gets change_source
     *
     * @return string
     */
    public function getChangeSource()
    {
        return $this->container['change_source'];
    }

    /**
     * Sets change_source
     *
     * @param string $change_source The system that last changed the customer record
     *
     * @return $this
     */
    public function setChangeSource($change_source)
    {
        $this->container['change_source'] = $change_source;

        return $this;
    }

    /**
     * Gets demographics
     *
     * @return \Advantage\Client\Model\DemographicValue[]
     */
    public function getDemographics()
    {
        return $this->container['demographics'];
    }

    /**
     * Sets demographics
     *
     * @param \Advantage\Client\Model\DemographicValue[] $demographics Customer demographic values (from the CUS-DMO1, CUS-DMO2, CUS-DMO3 partitions) to store on the  new customer record.
     *
     * @return $this
     */
    public function setDemographics($demographics)
    {
        $this->container['demographics'] = $demographics;

        return $this;
    }

    /**
     * Gets block_duplicate_match_level_code
     *
     * @return string
     */
    public function getBlockDuplicateMatchLevelCode()
    {
        return $this->container['block_duplicate_match_level_code'];
    }

    /**
     * Sets block_duplicate_match_level_code
     *
     * @param string $block_duplicate_match_level_code You can optionally block the addition of a new customer if a duplicate customer already exists.  To enable this check, specify a match level for the duplicate customer search.  If a duplicate  customer is found using this check then no customer is added and no customer information is returned.
     *
     * @return $this
     */
    public function setBlockDuplicateMatchLevelCode($block_duplicate_match_level_code)
    {
        $this->container['block_duplicate_match_level_code'] = $block_duplicate_match_level_code;

        return $this;
    }

    /**
     * Gets force_create
     *
     * @return bool
     */
    public function getForceCreate()
    {
        return $this->container['force_create'];
    }

    /**
     * Sets force_create
     *
     * @param bool $force_create In addition to the duplicate blocking feature, the Advantage API includes a set of system options  that can enable additional duplicate handling.  For example, the options can be configured such that  duplicate customers are prevented by converting a customer creation request into an update of the  existing (duplicate) customer.  Use the ForceCreate flag to override the duplicate handling settings  and always create new customers.
     *
     * @return $this
     */
    public function setForceCreate($force_create)
    {
        $this->container['force_create'] = $force_create;

        return $this;
    }

    /**
     * Gets is_account
     *
     * @return bool
     */
    public function getIsAccount()
    {
        return $this->container['is_account'];
    }

    /**
     * Sets is_account
     *
     * @param bool $is_account Is this an account customer?
     *
     * @return $this
     */
    public function setIsAccount($is_account)
    {
        $this->container['is_account'] = $is_account;

        return $this;
    }

    /**
     * Gets block_duplicate_match_with_activity
     *
     * @return bool
     */
    public function getBlockDuplicateMatchWithActivity()
    {
        return $this->container['block_duplicate_match_with_activity'];
    }

    /**
     * Sets block_duplicate_match_with_activity
     *
     * @param bool $block_duplicate_match_with_activity You can optionally block the addition of a new customer if a duplicate customer already exists.  To enable this check, specify a BlockDuplicateMatchLevelCode.  However, in some cases we may want   to require that a customer doesn't \"already exist\" unless they actually have activity (orders or authentication).   Without activity, these customer records are possibly just residue from simple email list participation.    This option works in conjunction with BlockDuplicateMatchLevelCode and says to only consider the existing customer \"found\"   if the they have activity.
     *
     * @return $this
     */
    public function setBlockDuplicateMatchWithActivity($block_duplicate_match_with_activity)
    {
        $this->container['block_duplicate_match_with_activity'] = $block_duplicate_match_with_activity;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset): mixed
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


