<?php
/**
 * Question
 *
 * PHP version 5
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Advantage.Rest.Services
 *
 * No description provided (generated by Advantage Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Advantage Codegen version: 2.4.20
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Advantage\Client\Model;

use \ArrayAccess;
use \Advantage\Client\ObjectSerializer;

/**
 * Question Class Doc Comment
 *
 * @category Class
 * @description A question to present to the user.  Several types of questions are supported.    Choose One and Choose Many questions include a list of choices.  Basic questions  can include a list of choices to use as suggested values.
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Question implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Question';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'question_code' => 'string',
        'question_type' => 'string',
        'data_type' => 'string',
        'prompt' => 'string',
        'max_length' => 'int',
        'name' => 'string',
        'default_response' => 'string',
        'choices' => '\Advantage\Client\Model\QuestionChoice[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'question_code' => null,
        'question_type' => null,
        'data_type' => null,
        'prompt' => null,
        'max_length' => 'int32',
        'name' => null,
        'default_response' => null,
        'choices' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'question_code' => 'QuestionCode',
        'question_type' => 'QuestionType',
        'data_type' => 'DataType',
        'prompt' => 'Prompt',
        'max_length' => 'MaxLength',
        'name' => 'Name',
        'default_response' => 'DefaultResponse',
        'choices' => 'Choices'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'question_code' => 'setQuestionCode',
        'question_type' => 'setQuestionType',
        'data_type' => 'setDataType',
        'prompt' => 'setPrompt',
        'max_length' => 'setMaxLength',
        'name' => 'setName',
        'default_response' => 'setDefaultResponse',
        'choices' => 'setChoices'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'question_code' => 'getQuestionCode',
        'question_type' => 'getQuestionType',
        'data_type' => 'getDataType',
        'prompt' => 'getPrompt',
        'max_length' => 'getMaxLength',
        'name' => 'getName',
        'default_response' => 'getDefaultResponse',
        'choices' => 'getChoices'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const QUESTION_TYPE_BASIC = 'Basic';
    const QUESTION_TYPE_CHOOSE_ONE = 'ChooseOne';
    const QUESTION_TYPE_CHOOSE_MANY = 'ChooseMany';
    const DATA_TYPE_TEXT = 'Text';
    const DATA_TYPE_INTEGER = 'Integer';
    const DATA_TYPE_DECIMAL = 'Decimal';
    const DATA_TYPE_DATE = 'Date';
    const DATA_TYPE_BOOLEAN = 'Boolean';
    const DATA_TYPE_FREE_FORM = 'FreeForm';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getQuestionTypeAllowableValues()
    {
        return [
            self::QUESTION_TYPE_BASIC,
            self::QUESTION_TYPE_CHOOSE_ONE,
            self::QUESTION_TYPE_CHOOSE_MANY,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDataTypeAllowableValues()
    {
        return [
            self::DATA_TYPE_TEXT,
            self::DATA_TYPE_INTEGER,
            self::DATA_TYPE_DECIMAL,
            self::DATA_TYPE_DATE,
            self::DATA_TYPE_BOOLEAN,
            self::DATA_TYPE_FREE_FORM,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['question_code'] = isset($data['question_code']) ? $data['question_code'] : null;
        $this->container['question_type'] = isset($data['question_type']) ? $data['question_type'] : null;
        $this->container['data_type'] = isset($data['data_type']) ? $data['data_type'] : null;
        $this->container['prompt'] = isset($data['prompt']) ? $data['prompt'] : null;
        $this->container['max_length'] = isset($data['max_length']) ? $data['max_length'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['default_response'] = isset($data['default_response']) ? $data['default_response'] : null;
        $this->container['choices'] = isset($data['choices']) ? $data['choices'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getQuestionTypeAllowableValues();
        if (!is_null($this->container['question_type']) && !in_array($this->container['question_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'question_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDataTypeAllowableValues();
        if (!is_null($this->container['data_type']) && !in_array($this->container['data_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'data_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets question_code
     *
     * @return string
     */
    public function getQuestionCode()
    {
        return $this->container['question_code'];
    }

    /**
     * Sets question_code
     *
     * @param string $question_code The question code uniquely identifies the question and is used when recording  responses
     *
     * @return $this
     */
    public function setQuestionCode($question_code)
    {
        $this->container['question_code'] = $question_code;

        return $this;
    }

    /**
     * Gets question_type
     *
     * @return string
     */
    public function getQuestionType()
    {
        return $this->container['question_type'];
    }

    /**
     * Sets question_type
     *
     * @param string $question_type The type of question.
     *
     * @return $this
     */
    public function setQuestionType($question_type)
    {
        $allowedValues = $this->getQuestionTypeAllowableValues();
        if (!is_null($question_type) && !in_array($question_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'question_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['question_type'] = $question_type;

        return $this;
    }

    /**
     * Gets data_type
     *
     * @return string
     */
    public function getDataType()
    {
        return $this->container['data_type'];
    }

    /**
     * Sets data_type
     *
     * @param string $data_type The data type for a basic question.
     *
     * @return $this
     */
    public function setDataType($data_type)
    {
        $allowedValues = $this->getDataTypeAllowableValues();
        if (!is_null($data_type) && !in_array($data_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'data_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['data_type'] = $data_type;

        return $this;
    }

    /**
     * Gets prompt
     *
     * @return string
     */
    public function getPrompt()
    {
        return $this->container['prompt'];
    }

    /**
     * Sets prompt
     *
     * @param string $prompt The text to use as the question prompt.
     *
     * @return $this
     */
    public function setPrompt($prompt)
    {
        $this->container['prompt'] = $prompt;

        return $this;
    }

    /**
     * Gets max_length
     *
     * @return int
     */
    public function getMaxLength()
    {
        return $this->container['max_length'];
    }

    /**
     * Sets max_length
     *
     * @param int $max_length The (optional) maximum length of a free form or basic question.
     *
     * @return $this
     */
    public function setMaxLength($max_length)
    {
        $this->container['max_length'] = $max_length;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The extended name of the question.  This might be used as help text.
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets default_response
     *
     * @return string
     */
    public function getDefaultResponse()
    {
        return $this->container['default_response'];
    }

    /**
     * Sets default_response
     *
     * @param string $default_response The default response for this question.  For a ChooseOne or ChooseMany question the DefaultResponse  is never populated.  Instead use the Selected property on the list of choices to see which choices  should be selected by default.  The format of a basic question response depends on   the DataType of the question.    A Basic/Boolean question response should be \"Y\" (for yes/true) or \"N\" (for no/false).      A Basic/Date question response should be a valid date formatted as YYYYMMDD where YYYY is the year, MM is   the month (1-12), DD is the day of month (1-31).      A Basic/Integer question should have an integer response where the integer is formated as a string of   digits with no punctuation.  The integer should have no more digits than the maximum allowed length of   the question.      A Basic/Decimal response should contain a number with no more than 18 digits to the left of the decimal   point and no more than 6 digits to the right.  The number should be formatted as a string of digits with   a period (.) separating the integer and fractional values, e.g. 12312.52    A Basic/Text question should have a text response no longer than the maximum allowed length.
     *
     * @return $this
     */
    public function setDefaultResponse($default_response)
    {
        $this->container['default_response'] = $default_response;

        return $this;
    }

    /**
     * Gets choices
     *
     * @return \Advantage\Client\Model\QuestionChoice[]
     */
    public function getChoices()
    {
        return $this->container['choices'];
    }

    /**
     * Sets choices
     *
     * @param \Advantage\Client\Model\QuestionChoice[] $choices The list of choices for a Choose One or Choose Many question, or an optional  list of suggested values for Basic questions.
     *
     * @return $this
     */
    public function setChoices($choices)
    {
        $this->container['choices'] = $choices;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


