<?php
/**
 * PremiumSetDetailUpdateRequest
 *
 * PHP version 5
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Advantage.Rest.Services
 *
 * No description provided (generated by Advantage Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Advantage Codegen version: 2.4.20
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Advantage\Client\Model;

use \ArrayAccess;
use \Advantage\Client\ObjectSerializer;

/**
 * PremiumSetDetailUpdateRequest Class Doc Comment
 *
 * @category Class
 * @description The premium set detail update request allows you to update a premium set detail.  All properties of the update request are optional.  If a property is not set in the request object then it will not be updated.
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PremiumSetDetailUpdateRequest implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'PremiumSetDetailUpdateRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'fulfill_at' => 'string',
        'assembly_package' => 'string',
        'select_only_once' => 'bool',
        'premiums' => '\Advantage\Client\Model\PremiumSetDetailItem[]',
        'earning_criteria' => '\Advantage\Client\Model\PremiumSetEarningCriteria',
        'subscription_adjustments' => '\Advantage\Client\Model\PremiumSetSubscriptionAdjustments'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'fulfill_at' => null,
        'assembly_package' => null,
        'select_only_once' => null,
        'premiums' => null,
        'earning_criteria' => null,
        'subscription_adjustments' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'fulfill_at' => 'FulfillAt',
        'assembly_package' => 'AssemblyPackage',
        'select_only_once' => 'SelectOnlyOnce',
        'premiums' => 'Premiums',
        'earning_criteria' => 'EarningCriteria',
        'subscription_adjustments' => 'SubscriptionAdjustments'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'fulfill_at' => 'setFulfillAt',
        'assembly_package' => 'setAssemblyPackage',
        'select_only_once' => 'setSelectOnlyOnce',
        'premiums' => 'setPremiums',
        'earning_criteria' => 'setEarningCriteria',
        'subscription_adjustments' => 'setSubscriptionAdjustments'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'fulfill_at' => 'getFulfillAt',
        'assembly_package' => 'getAssemblyPackage',
        'select_only_once' => 'getSelectOnlyOnce',
        'premiums' => 'getPremiums',
        'earning_criteria' => 'getEarningCriteria',
        'subscription_adjustments' => 'getSubscriptionAdjustments'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const FULFILL_AT_FULFILL_WHEN_EARNED = 'FulfillWhenEarned';
    const FULFILL_AT_FULFILL_WITH_ISSUE = 'FulfillWithIssue';
    const FULFILL_AT_FULFILL_AFTER_NEXT_BOOK_CLUB_ORDER = 'FulfillAfterNextBookClubOrder';
    const FULFILL_AT_FULFILL_THROUGH_SEPARATE_ORDER = 'FulfillThroughSeparateOrder';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFulfillAtAllowableValues()
    {
        return [
            self::FULFILL_AT_FULFILL_WHEN_EARNED,
            self::FULFILL_AT_FULFILL_WITH_ISSUE,
            self::FULFILL_AT_FULFILL_AFTER_NEXT_BOOK_CLUB_ORDER,
            self::FULFILL_AT_FULFILL_THROUGH_SEPARATE_ORDER,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['fulfill_at'] = isset($data['fulfill_at']) ? $data['fulfill_at'] : null;
        $this->container['assembly_package'] = isset($data['assembly_package']) ? $data['assembly_package'] : null;
        $this->container['select_only_once'] = isset($data['select_only_once']) ? $data['select_only_once'] : null;
        $this->container['premiums'] = isset($data['premiums']) ? $data['premiums'] : null;
        $this->container['earning_criteria'] = isset($data['earning_criteria']) ? $data['earning_criteria'] : null;
        $this->container['subscription_adjustments'] = isset($data['subscription_adjustments']) ? $data['subscription_adjustments'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getFulfillAtAllowableValues();
        if (!is_null($this->container['fulfill_at']) && !in_array($this->container['fulfill_at'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'fulfill_at', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets fulfill_at
     *
     * @return string
     */
    public function getFulfillAt()
    {
        return $this->container['fulfill_at'];
    }

    /**
     * Sets fulfill_at
     *
     * @param string $fulfill_at Specifies when the premium earned should be shipped.
     *
     * @return $this
     */
    public function setFulfillAt($fulfill_at)
    {
        $allowedValues = $this->getFulfillAtAllowableValues();
        if (!is_null($fulfill_at) && !in_array($fulfill_at, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'fulfill_at', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fulfill_at'] = $fulfill_at;

        return $this;
    }

    /**
     * Gets assembly_package
     *
     * @return string
     */
    public function getAssemblyPackage()
    {
        return $this->container['assembly_package'];
    }

    /**
     * Sets assembly_package
     *
     * @param string $assembly_package The assembly package code identifies a particular combination of forms, materials and promotions for a shipment.
     *
     * @return $this
     */
    public function setAssemblyPackage($assembly_package)
    {
        $this->container['assembly_package'] = $assembly_package;

        return $this;
    }

    /**
     * Gets select_only_once
     *
     * @return bool
     */
    public function getSelectOnlyOnce()
    {
        return $this->container['select_only_once'];
    }

    /**
     * Sets select_only_once
     *
     * @param bool $select_only_once The Select Only Once flag controls whether all or only the first matching premium set sequences are fulfilled.
     *
     * @return $this
     */
    public function setSelectOnlyOnce($select_only_once)
    {
        $this->container['select_only_once'] = $select_only_once;

        return $this;
    }

    /**
     * Gets premiums
     *
     * @return \Advantage\Client\Model\PremiumSetDetailItem[]
     */
    public function getPremiums()
    {
        return $this->container['premiums'];
    }

    /**
     * Sets premiums
     *
     * @param \Advantage\Client\Model\PremiumSetDetailItem[] $premiums The list of premium items awarded for this premium set. Up to four may be specified.  Any items in this list that have an item number will be completely overwritten.
     *
     * @return $this
     */
    public function setPremiums($premiums)
    {
        $this->container['premiums'] = $premiums;

        return $this;
    }

    /**
     * Gets earning_criteria
     *
     * @return \Advantage\Client\Model\PremiumSetEarningCriteria
     */
    public function getEarningCriteria()
    {
        return $this->container['earning_criteria'];
    }

    /**
     * Sets earning_criteria
     *
     * @param \Advantage\Client\Model\PremiumSetEarningCriteria $earning_criteria Information for how the premium set will be earned.
     *
     * @return $this
     */
    public function setEarningCriteria($earning_criteria)
    {
        $this->container['earning_criteria'] = $earning_criteria;

        return $this;
    }

    /**
     * Gets subscription_adjustments
     *
     * @return \Advantage\Client\Model\PremiumSetSubscriptionAdjustments
     */
    public function getSubscriptionAdjustments()
    {
        return $this->container['subscription_adjustments'];
    }

    /**
     * Sets subscription_adjustments
     *
     * @param \Advantage\Client\Model\PremiumSetSubscriptionAdjustments $subscription_adjustments Information for subscription adjustments on the premium set.
     *
     * @return $this
     */
    public function setSubscriptionAdjustments($subscription_adjustments)
    {
        $this->container['subscription_adjustments'] = $subscription_adjustments;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


