<?php
/**
 * SalesRepApi
 * PHP version 5
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Advantage.Rest.Services
 *
 * No description provided (generated by Advantage Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Advantage Codegen version: 2.4.20
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Advantage\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Advantage\Client\ApiException;
use Advantage\Client\Configuration;
use Advantage\Client\HeaderSelector;
use Advantage\Client\ObjectSerializer;

/**
 * SalesRepApi Class Doc Comment
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SalesRepApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation salesRepCreateOrUpdate
     *
     * Create or Update a Sales Rep from a SalesRep Model
     *
     * @param  \Advantage\Client\Model\SalesRepIn $sales_rep_in Model to Create/Update Password Question (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SalesRep
     */
    public function salesRepCreateOrUpdate($sales_rep_in)
    {
        list($response) = $this->salesRepCreateOrUpdateWithHttpInfo($sales_rep_in);
        return $response;
    }

    /**
     * Operation salesRepCreateOrUpdateWithHttpInfo
     *
     * Create or Update a Sales Rep from a SalesRep Model
     *
     * @param  \Advantage\Client\Model\SalesRepIn $sales_rep_in Model to Create/Update Password Question (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SalesRep, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepCreateOrUpdateWithHttpInfo($sales_rep_in)
    {
        $returnType = '\Advantage\Client\Model\SalesRep';
        $request = $this->salesRepCreateOrUpdateRequest($sales_rep_in);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SalesRep',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepCreateOrUpdateAsync
     *
     * Create or Update a Sales Rep from a SalesRep Model
     *
     * @param  \Advantage\Client\Model\SalesRepIn $sales_rep_in Model to Create/Update Password Question (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepCreateOrUpdateAsync($sales_rep_in)
    {
        return $this->salesRepCreateOrUpdateAsyncWithHttpInfo($sales_rep_in)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepCreateOrUpdateAsyncWithHttpInfo
     *
     * Create or Update a Sales Rep from a SalesRep Model
     *
     * @param  \Advantage\Client\Model\SalesRepIn $sales_rep_in Model to Create/Update Password Question (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepCreateOrUpdateAsyncWithHttpInfo($sales_rep_in)
    {
        $returnType = '\Advantage\Client\Model\SalesRep';
        $request = $this->salesRepCreateOrUpdateRequest($sales_rep_in);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepCreateOrUpdate'
     *
     * @param  \Advantage\Client\Model\SalesRepIn $sales_rep_in Model to Create/Update Password Question (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepCreateOrUpdateRequest($sales_rep_in)
    {
        // verify the required parameter 'sales_rep_in' is set
        if ($sales_rep_in === null || (is_array($sales_rep_in) && count($sales_rep_in) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_in when calling salesRepCreateOrUpdate'
            );
        }

        $resourcePath = '/sales-reps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($sales_rep_in)) {
            $_tempBody = $sales_rep_in;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGet
     *
     * Gets Sales Rep.
     *
     * @param  string $sales_rep_code The sales rep number (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SalesRep
     */
    public function salesRepGet($sales_rep_code)
    {
        list($response) = $this->salesRepGetWithHttpInfo($sales_rep_code);
        return $response;
    }

    /**
     * Operation salesRepGetWithHttpInfo
     *
     * Gets Sales Rep.
     *
     * @param  string $sales_rep_code The sales rep number (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SalesRep, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetWithHttpInfo($sales_rep_code)
    {
        $returnType = '\Advantage\Client\Model\SalesRep';
        $request = $this->salesRepGetRequest($sales_rep_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SalesRep',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetAsync
     *
     * Gets Sales Rep.
     *
     * @param  string $sales_rep_code The sales rep number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetAsync($sales_rep_code)
    {
        return $this->salesRepGetAsyncWithHttpInfo($sales_rep_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetAsyncWithHttpInfo
     *
     * Gets Sales Rep.
     *
     * @param  string $sales_rep_code The sales rep number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetAsyncWithHttpInfo($sales_rep_code)
    {
        $returnType = '\Advantage\Client\Model\SalesRep';
        $request = $this->salesRepGetRequest($sales_rep_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGet'
     *
     * @param  string $sales_rep_code The sales rep number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetRequest($sales_rep_code)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepGet'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetCallHistory
     *
     * Returns call history records for the specified sales rep
     *
     * @param  string $sales_rep_code Sales rep code (required)
     * @param  bool $include_closed If true, include history records for closed calls (resolution code &#39;L&#39;) (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultCallHistory
     */
    public function salesRepGetCallHistory($sales_rep_code, $include_closed = null, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->salesRepGetCallHistoryWithHttpInfo($sales_rep_code, $include_closed, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation salesRepGetCallHistoryWithHttpInfo
     *
     * Returns call history records for the specified sales rep
     *
     * @param  string $sales_rep_code Sales rep code (required)
     * @param  bool $include_closed If true, include history records for closed calls (resolution code &#39;L&#39;) (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultCallHistory, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetCallHistoryWithHttpInfo($sales_rep_code, $include_closed = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCallHistory';
        $request = $this->salesRepGetCallHistoryRequest($sales_rep_code, $include_closed, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultCallHistory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetCallHistoryAsync
     *
     * Returns call history records for the specified sales rep
     *
     * @param  string $sales_rep_code Sales rep code (required)
     * @param  bool $include_closed If true, include history records for closed calls (resolution code &#39;L&#39;) (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallHistoryAsync($sales_rep_code, $include_closed = null, $pager_skip = null, $pager_take = null)
    {
        return $this->salesRepGetCallHistoryAsyncWithHttpInfo($sales_rep_code, $include_closed, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetCallHistoryAsyncWithHttpInfo
     *
     * Returns call history records for the specified sales rep
     *
     * @param  string $sales_rep_code Sales rep code (required)
     * @param  bool $include_closed If true, include history records for closed calls (resolution code &#39;L&#39;) (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallHistoryAsyncWithHttpInfo($sales_rep_code, $include_closed = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCallHistory';
        $request = $this->salesRepGetCallHistoryRequest($sales_rep_code, $include_closed, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetCallHistory'
     *
     * @param  string $sales_rep_code Sales rep code (required)
     * @param  bool $include_closed If true, include history records for closed calls (resolution code &#39;L&#39;) (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetCallHistoryRequest($sales_rep_code, $include_closed = null, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepGetCallHistory'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}/call-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_closed !== null) {
            $queryParams['includeClosed'] = ObjectSerializer::toQueryValue($include_closed);
        }
        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetCallListAssignments
     *
     * Gets a list of call list assignments for a given sales representative.
     *
     * @param  string $sales_rep_code Sales Rep Code (required)
     * @param  bool $include_inactive_lists If true, include inactive lists (optional)
     * @param  bool $only_include_lists_with_calls_remaining If true, only include lists with calls remaining (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultCallListAssignment
     */
    public function salesRepGetCallListAssignments($sales_rep_code, $include_inactive_lists = null, $only_include_lists_with_calls_remaining = null)
    {
        list($response) = $this->salesRepGetCallListAssignmentsWithHttpInfo($sales_rep_code, $include_inactive_lists, $only_include_lists_with_calls_remaining);
        return $response;
    }

    /**
     * Operation salesRepGetCallListAssignmentsWithHttpInfo
     *
     * Gets a list of call list assignments for a given sales representative.
     *
     * @param  string $sales_rep_code Sales Rep Code (required)
     * @param  bool $include_inactive_lists If true, include inactive lists (optional)
     * @param  bool $only_include_lists_with_calls_remaining If true, only include lists with calls remaining (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultCallListAssignment, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetCallListAssignmentsWithHttpInfo($sales_rep_code, $include_inactive_lists = null, $only_include_lists_with_calls_remaining = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCallListAssignment';
        $request = $this->salesRepGetCallListAssignmentsRequest($sales_rep_code, $include_inactive_lists, $only_include_lists_with_calls_remaining);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultCallListAssignment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetCallListAssignmentsAsync
     *
     * Gets a list of call list assignments for a given sales representative.
     *
     * @param  string $sales_rep_code Sales Rep Code (required)
     * @param  bool $include_inactive_lists If true, include inactive lists (optional)
     * @param  bool $only_include_lists_with_calls_remaining If true, only include lists with calls remaining (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallListAssignmentsAsync($sales_rep_code, $include_inactive_lists = null, $only_include_lists_with_calls_remaining = null)
    {
        return $this->salesRepGetCallListAssignmentsAsyncWithHttpInfo($sales_rep_code, $include_inactive_lists, $only_include_lists_with_calls_remaining)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetCallListAssignmentsAsyncWithHttpInfo
     *
     * Gets a list of call list assignments for a given sales representative.
     *
     * @param  string $sales_rep_code Sales Rep Code (required)
     * @param  bool $include_inactive_lists If true, include inactive lists (optional)
     * @param  bool $only_include_lists_with_calls_remaining If true, only include lists with calls remaining (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallListAssignmentsAsyncWithHttpInfo($sales_rep_code, $include_inactive_lists = null, $only_include_lists_with_calls_remaining = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCallListAssignment';
        $request = $this->salesRepGetCallListAssignmentsRequest($sales_rep_code, $include_inactive_lists, $only_include_lists_with_calls_remaining);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetCallListAssignments'
     *
     * @param  string $sales_rep_code Sales Rep Code (required)
     * @param  bool $include_inactive_lists If true, include inactive lists (optional)
     * @param  bool $only_include_lists_with_calls_remaining If true, only include lists with calls remaining (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetCallListAssignmentsRequest($sales_rep_code, $include_inactive_lists = null, $only_include_lists_with_calls_remaining = null)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepGetCallListAssignments'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}/call-lists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_inactive_lists !== null) {
            $queryParams['includeInactiveLists'] = ObjectSerializer::toQueryValue($include_inactive_lists);
        }
        // query params
        if ($only_include_lists_with_calls_remaining !== null) {
            $queryParams['onlyIncludeListsWithCallsRemaining'] = ObjectSerializer::toQueryValue($only_include_lists_with_calls_remaining);
        }

        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetCallStatistics
     *
     * Gets call statistics for a particular date range.
     *
     * @param  string $sales_rep_code Sales rep code for statistics range (required)
     * @param  bool $is_manager Whether the sales rep is the manager of the team for which department rank will be calculated (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\CallStatistics
     */
    public function salesRepGetCallStatistics($sales_rep_code, $is_manager, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        list($response) = $this->salesRepGetCallStatisticsWithHttpInfo($sales_rep_code, $is_manager, $display_currency, $filter_begin_date, $filter_end_date, $filter_list_code, $filter_list_date);
        return $response;
    }

    /**
     * Operation salesRepGetCallStatisticsWithHttpInfo
     *
     * Gets call statistics for a particular date range.
     *
     * @param  string $sales_rep_code Sales rep code for statistics range (required)
     * @param  bool $is_manager Whether the sales rep is the manager of the team for which department rank will be calculated (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\CallStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetCallStatisticsWithHttpInfo($sales_rep_code, $is_manager, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        $returnType = '\Advantage\Client\Model\CallStatistics';
        $request = $this->salesRepGetCallStatisticsRequest($sales_rep_code, $is_manager, $display_currency, $filter_begin_date, $filter_end_date, $filter_list_code, $filter_list_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\CallStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetCallStatisticsAsync
     *
     * Gets call statistics for a particular date range.
     *
     * @param  string $sales_rep_code Sales rep code for statistics range (required)
     * @param  bool $is_manager Whether the sales rep is the manager of the team for which department rank will be calculated (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallStatisticsAsync($sales_rep_code, $is_manager, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        return $this->salesRepGetCallStatisticsAsyncWithHttpInfo($sales_rep_code, $is_manager, $display_currency, $filter_begin_date, $filter_end_date, $filter_list_code, $filter_list_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetCallStatisticsAsyncWithHttpInfo
     *
     * Gets call statistics for a particular date range.
     *
     * @param  string $sales_rep_code Sales rep code for statistics range (required)
     * @param  bool $is_manager Whether the sales rep is the manager of the team for which department rank will be calculated (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallStatisticsAsyncWithHttpInfo($sales_rep_code, $is_manager, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        $returnType = '\Advantage\Client\Model\CallStatistics';
        $request = $this->salesRepGetCallStatisticsRequest($sales_rep_code, $is_manager, $display_currency, $filter_begin_date, $filter_end_date, $filter_list_code, $filter_list_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetCallStatistics'
     *
     * @param  string $sales_rep_code Sales rep code for statistics range (required)
     * @param  bool $is_manager Whether the sales rep is the manager of the team for which department rank will be calculated (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetCallStatisticsRequest($sales_rep_code, $is_manager, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepGetCallStatistics'
            );
        }
        // verify the required parameter 'is_manager' is set
        if ($is_manager === null || (is_array($is_manager) && count($is_manager) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $is_manager when calling salesRepGetCallStatistics'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}/call-statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_manager !== null) {
            $queryParams['isManager'] = ObjectSerializer::toQueryValue($is_manager);
        }
        // query params
        if ($display_currency !== null) {
            $queryParams['displayCurrency'] = ObjectSerializer::toQueryValue($display_currency);
        }
        // query params
        if ($filter_begin_date !== null) {
            $queryParams['filter.beginDate'] = ObjectSerializer::toQueryValue($filter_begin_date);
        }
        // query params
        if ($filter_end_date !== null) {
            $queryParams['filter.endDate'] = ObjectSerializer::toQueryValue($filter_end_date);
        }
        // query params
        if ($filter_list_code !== null) {
            $queryParams['filter.listCode'] = ObjectSerializer::toQueryValue($filter_list_code);
        }
        // query params
        if ($filter_list_date !== null) {
            $queryParams['filter.listDate'] = ObjectSerializer::toQueryValue($filter_list_date);
        }

        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetCallbacks
     *
     * Gets list of tele-service callbacks.
     *
     * @param  string $sales_rep_code Sales rep code for rep assigned to callbacks (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  \DateTime $filter_begin_date The beginning date. Only calls with callback date on or after this date will be returned. (optional)
     * @param  \DateTime $filter_end_date The beginning date. Only calls with callback date on or before this date will be returned. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultCall
     */
    public function salesRepGetCallbacks($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_begin_date = null, $filter_end_date = null, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->salesRepGetCallbacksWithHttpInfo($sales_rep_code, $filter_list_id, $filter_list_date, $filter_begin_date, $filter_end_date, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation salesRepGetCallbacksWithHttpInfo
     *
     * Gets list of tele-service callbacks.
     *
     * @param  string $sales_rep_code Sales rep code for rep assigned to callbacks (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  \DateTime $filter_begin_date The beginning date. Only calls with callback date on or after this date will be returned. (optional)
     * @param  \DateTime $filter_end_date The beginning date. Only calls with callback date on or before this date will be returned. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultCall, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetCallbacksWithHttpInfo($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_begin_date = null, $filter_end_date = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCall';
        $request = $this->salesRepGetCallbacksRequest($sales_rep_code, $filter_list_id, $filter_list_date, $filter_begin_date, $filter_end_date, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultCall',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetCallbacksAsync
     *
     * Gets list of tele-service callbacks.
     *
     * @param  string $sales_rep_code Sales rep code for rep assigned to callbacks (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  \DateTime $filter_begin_date The beginning date. Only calls with callback date on or after this date will be returned. (optional)
     * @param  \DateTime $filter_end_date The beginning date. Only calls with callback date on or before this date will be returned. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallbacksAsync($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_begin_date = null, $filter_end_date = null, $pager_skip = null, $pager_take = null)
    {
        return $this->salesRepGetCallbacksAsyncWithHttpInfo($sales_rep_code, $filter_list_id, $filter_list_date, $filter_begin_date, $filter_end_date, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetCallbacksAsyncWithHttpInfo
     *
     * Gets list of tele-service callbacks.
     *
     * @param  string $sales_rep_code Sales rep code for rep assigned to callbacks (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  \DateTime $filter_begin_date The beginning date. Only calls with callback date on or after this date will be returned. (optional)
     * @param  \DateTime $filter_end_date The beginning date. Only calls with callback date on or before this date will be returned. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallbacksAsyncWithHttpInfo($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_begin_date = null, $filter_end_date = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCall';
        $request = $this->salesRepGetCallbacksRequest($sales_rep_code, $filter_list_id, $filter_list_date, $filter_begin_date, $filter_end_date, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetCallbacks'
     *
     * @param  string $sales_rep_code Sales rep code for rep assigned to callbacks (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  \DateTime $filter_begin_date The beginning date. Only calls with callback date on or after this date will be returned. (optional)
     * @param  \DateTime $filter_end_date The beginning date. Only calls with callback date on or before this date will be returned. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetCallbacksRequest($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_begin_date = null, $filter_end_date = null, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepGetCallbacks'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}/callbacks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter_list_id !== null) {
            $queryParams['filter.listId'] = ObjectSerializer::toQueryValue($filter_list_id);
        }
        // query params
        if ($filter_list_date !== null) {
            $queryParams['filter.listDate'] = ObjectSerializer::toQueryValue($filter_list_date);
        }
        // query params
        if ($filter_begin_date !== null) {
            $queryParams['filter.beginDate'] = ObjectSerializer::toQueryValue($filter_begin_date);
        }
        // query params
        if ($filter_end_date !== null) {
            $queryParams['filter.endDate'] = ObjectSerializer::toQueryValue($filter_end_date);
        }
        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetCallsForList
     *
     * Gets a list of calls for a given sales representative.
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  bool $include_callbacks True to include callbacks (optional)
     * @param  bool $include_contacted True to include calls for customers who have been contacted at least once (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultCall
     */
    public function salesRepGetCallsForList($sales_rep_code, $list_id, $list_date, $include_callbacks = null, $include_contacted = null, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->salesRepGetCallsForListWithHttpInfo($sales_rep_code, $list_id, $list_date, $include_callbacks, $include_contacted, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation salesRepGetCallsForListWithHttpInfo
     *
     * Gets a list of calls for a given sales representative.
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  bool $include_callbacks True to include callbacks (optional)
     * @param  bool $include_contacted True to include calls for customers who have been contacted at least once (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultCall, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetCallsForListWithHttpInfo($sales_rep_code, $list_id, $list_date, $include_callbacks = null, $include_contacted = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCall';
        $request = $this->salesRepGetCallsForListRequest($sales_rep_code, $list_id, $list_date, $include_callbacks, $include_contacted, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultCall',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetCallsForListAsync
     *
     * Gets a list of calls for a given sales representative.
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  bool $include_callbacks True to include callbacks (optional)
     * @param  bool $include_contacted True to include calls for customers who have been contacted at least once (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallsForListAsync($sales_rep_code, $list_id, $list_date, $include_callbacks = null, $include_contacted = null, $pager_skip = null, $pager_take = null)
    {
        return $this->salesRepGetCallsForListAsyncWithHttpInfo($sales_rep_code, $list_id, $list_date, $include_callbacks, $include_contacted, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetCallsForListAsyncWithHttpInfo
     *
     * Gets a list of calls for a given sales representative.
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  bool $include_callbacks True to include callbacks (optional)
     * @param  bool $include_contacted True to include calls for customers who have been contacted at least once (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallsForListAsyncWithHttpInfo($sales_rep_code, $list_id, $list_date, $include_callbacks = null, $include_contacted = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCall';
        $request = $this->salesRepGetCallsForListRequest($sales_rep_code, $list_id, $list_date, $include_callbacks, $include_contacted, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetCallsForList'
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  bool $include_callbacks True to include callbacks (optional)
     * @param  bool $include_contacted True to include calls for customers who have been contacted at least once (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetCallsForListRequest($sales_rep_code, $list_id, $list_date, $include_callbacks = null, $include_contacted = null, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepGetCallsForList'
            );
        }
        // verify the required parameter 'list_id' is set
        if ($list_id === null || (is_array($list_id) && count($list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $list_id when calling salesRepGetCallsForList'
            );
        }
        // verify the required parameter 'list_date' is set
        if ($list_date === null || (is_array($list_date) && count($list_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $list_date when calling salesRepGetCallsForList'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}/call-lists/{listId}/{listDate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_callbacks !== null) {
            $queryParams['includeCallbacks'] = ObjectSerializer::toQueryValue($include_callbacks);
        }
        // query params
        if ($include_contacted !== null) {
            $queryParams['includeContacted'] = ObjectSerializer::toQueryValue($include_contacted);
        }
        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }
        // path params
        if ($list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'listId' . '}',
                ObjectSerializer::toPathValue($list_id),
                $resourcePath
            );
        }
        // path params
        if ($list_date !== null) {
            $resourcePath = str_replace(
                '{' . 'listDate' . '}',
                ObjectSerializer::toPathValue($list_date),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetCallsForSalesRep
     *
     * Gets a list of calls for a given sales representative.
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  bool $filter_include_completed True to include calls that have been completed (optional)
     * @param  bool $filter_include_contacted True to include calls where the customer has been contacted (optional)
     * @param  bool $filter_include_callbacks True to include calls callbacks (optional)
     * @param  bool $filter_include_uncontacted True to include calls that have been made (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultCall
     */
    public function salesRepGetCallsForSalesRep($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_include_completed = null, $filter_include_contacted = null, $filter_include_callbacks = null, $filter_include_uncontacted = null)
    {
        list($response) = $this->salesRepGetCallsForSalesRepWithHttpInfo($sales_rep_code, $filter_list_id, $filter_list_date, $filter_include_completed, $filter_include_contacted, $filter_include_callbacks, $filter_include_uncontacted);
        return $response;
    }

    /**
     * Operation salesRepGetCallsForSalesRepWithHttpInfo
     *
     * Gets a list of calls for a given sales representative.
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  bool $filter_include_completed True to include calls that have been completed (optional)
     * @param  bool $filter_include_contacted True to include calls where the customer has been contacted (optional)
     * @param  bool $filter_include_callbacks True to include calls callbacks (optional)
     * @param  bool $filter_include_uncontacted True to include calls that have been made (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultCall, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetCallsForSalesRepWithHttpInfo($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_include_completed = null, $filter_include_contacted = null, $filter_include_callbacks = null, $filter_include_uncontacted = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCall';
        $request = $this->salesRepGetCallsForSalesRepRequest($sales_rep_code, $filter_list_id, $filter_list_date, $filter_include_completed, $filter_include_contacted, $filter_include_callbacks, $filter_include_uncontacted);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultCall',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetCallsForSalesRepAsync
     *
     * Gets a list of calls for a given sales representative.
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  bool $filter_include_completed True to include calls that have been completed (optional)
     * @param  bool $filter_include_contacted True to include calls where the customer has been contacted (optional)
     * @param  bool $filter_include_callbacks True to include calls callbacks (optional)
     * @param  bool $filter_include_uncontacted True to include calls that have been made (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallsForSalesRepAsync($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_include_completed = null, $filter_include_contacted = null, $filter_include_callbacks = null, $filter_include_uncontacted = null)
    {
        return $this->salesRepGetCallsForSalesRepAsyncWithHttpInfo($sales_rep_code, $filter_list_id, $filter_list_date, $filter_include_completed, $filter_include_contacted, $filter_include_callbacks, $filter_include_uncontacted)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetCallsForSalesRepAsyncWithHttpInfo
     *
     * Gets a list of calls for a given sales representative.
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  bool $filter_include_completed True to include calls that have been completed (optional)
     * @param  bool $filter_include_contacted True to include calls where the customer has been contacted (optional)
     * @param  bool $filter_include_callbacks True to include calls callbacks (optional)
     * @param  bool $filter_include_uncontacted True to include calls that have been made (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetCallsForSalesRepAsyncWithHttpInfo($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_include_completed = null, $filter_include_contacted = null, $filter_include_callbacks = null, $filter_include_uncontacted = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCall';
        $request = $this->salesRepGetCallsForSalesRepRequest($sales_rep_code, $filter_list_id, $filter_list_date, $filter_include_completed, $filter_include_contacted, $filter_include_callbacks, $filter_include_uncontacted);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetCallsForSalesRep'
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $filter_list_id The List Id of the list to filter results by (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     * @param  bool $filter_include_completed True to include calls that have been completed (optional)
     * @param  bool $filter_include_contacted True to include calls where the customer has been contacted (optional)
     * @param  bool $filter_include_callbacks True to include calls callbacks (optional)
     * @param  bool $filter_include_uncontacted True to include calls that have been made (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetCallsForSalesRepRequest($sales_rep_code, $filter_list_id = null, $filter_list_date = null, $filter_include_completed = null, $filter_include_contacted = null, $filter_include_callbacks = null, $filter_include_uncontacted = null)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepGetCallsForSalesRep'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}/calls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter_list_id !== null) {
            $queryParams['filter.listId'] = ObjectSerializer::toQueryValue($filter_list_id);
        }
        // query params
        if ($filter_list_date !== null) {
            $queryParams['filter.listDate'] = ObjectSerializer::toQueryValue($filter_list_date);
        }
        // query params
        if ($filter_include_completed !== null) {
            $queryParams['filter.includeCompleted'] = ObjectSerializer::toQueryValue($filter_include_completed);
        }
        // query params
        if ($filter_include_contacted !== null) {
            $queryParams['filter.includeContacted'] = ObjectSerializer::toQueryValue($filter_include_contacted);
        }
        // query params
        if ($filter_include_callbacks !== null) {
            $queryParams['filter.includeCallbacks'] = ObjectSerializer::toQueryValue($filter_include_callbacks);
        }
        // query params
        if ($filter_include_uncontacted !== null) {
            $queryParams['filter.includeUncontacted'] = ObjectSerializer::toQueryValue($filter_include_uncontacted);
        }

        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetList
     *
     * Gets List of Sales Reps.
     *
     * @param  string $customer_number Default null to return list of all sales reps,                  pass in CustomerNumber to Get List by customer number (optional)
     * @param  bool $exclude_unmapped_reps If true, will only return information for reps with a user mapping (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultSalesRep
     */
    public function salesRepGetList($customer_number = null, $exclude_unmapped_reps = null)
    {
        list($response) = $this->salesRepGetListWithHttpInfo($customer_number, $exclude_unmapped_reps);
        return $response;
    }

    /**
     * Operation salesRepGetListWithHttpInfo
     *
     * Gets List of Sales Reps.
     *
     * @param  string $customer_number Default null to return list of all sales reps,                  pass in CustomerNumber to Get List by customer number (optional)
     * @param  bool $exclude_unmapped_reps If true, will only return information for reps with a user mapping (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultSalesRep, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetListWithHttpInfo($customer_number = null, $exclude_unmapped_reps = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultSalesRep';
        $request = $this->salesRepGetListRequest($customer_number, $exclude_unmapped_reps);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultSalesRep',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetListAsync
     *
     * Gets List of Sales Reps.
     *
     * @param  string $customer_number Default null to return list of all sales reps,                  pass in CustomerNumber to Get List by customer number (optional)
     * @param  bool $exclude_unmapped_reps If true, will only return information for reps with a user mapping (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetListAsync($customer_number = null, $exclude_unmapped_reps = null)
    {
        return $this->salesRepGetListAsyncWithHttpInfo($customer_number, $exclude_unmapped_reps)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetListAsyncWithHttpInfo
     *
     * Gets List of Sales Reps.
     *
     * @param  string $customer_number Default null to return list of all sales reps,                  pass in CustomerNumber to Get List by customer number (optional)
     * @param  bool $exclude_unmapped_reps If true, will only return information for reps with a user mapping (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetListAsyncWithHttpInfo($customer_number = null, $exclude_unmapped_reps = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultSalesRep';
        $request = $this->salesRepGetListRequest($customer_number, $exclude_unmapped_reps);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetList'
     *
     * @param  string $customer_number Default null to return list of all sales reps,                  pass in CustomerNumber to Get List by customer number (optional)
     * @param  bool $exclude_unmapped_reps If true, will only return information for reps with a user mapping (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetListRequest($customer_number = null, $exclude_unmapped_reps = null)
    {

        $resourcePath = '/sales-reps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($customer_number !== null) {
            $queryParams['customerNumber'] = ObjectSerializer::toQueryValue($customer_number);
        }
        // query params
        if ($exclude_unmapped_reps !== null) {
            $queryParams['excludeUnmappedReps'] = ObjectSerializer::toQueryValue($exclude_unmapped_reps);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetSalesRepsBySupervisor
     *
     * Gets list of sales reps under a supervisor (List includes supervisor)
     *
     * @param  string $supervisor_code Supervisor&#39;s sales rep code (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultSalesRep
     */
    public function salesRepGetSalesRepsBySupervisor($supervisor_code)
    {
        list($response) = $this->salesRepGetSalesRepsBySupervisorWithHttpInfo($supervisor_code);
        return $response;
    }

    /**
     * Operation salesRepGetSalesRepsBySupervisorWithHttpInfo
     *
     * Gets list of sales reps under a supervisor (List includes supervisor)
     *
     * @param  string $supervisor_code Supervisor&#39;s sales rep code (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultSalesRep, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetSalesRepsBySupervisorWithHttpInfo($supervisor_code)
    {
        $returnType = '\Advantage\Client\Model\SearchResultSalesRep';
        $request = $this->salesRepGetSalesRepsBySupervisorRequest($supervisor_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultSalesRep',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetSalesRepsBySupervisorAsync
     *
     * Gets list of sales reps under a supervisor (List includes supervisor)
     *
     * @param  string $supervisor_code Supervisor&#39;s sales rep code (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetSalesRepsBySupervisorAsync($supervisor_code)
    {
        return $this->salesRepGetSalesRepsBySupervisorAsyncWithHttpInfo($supervisor_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetSalesRepsBySupervisorAsyncWithHttpInfo
     *
     * Gets list of sales reps under a supervisor (List includes supervisor)
     *
     * @param  string $supervisor_code Supervisor&#39;s sales rep code (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetSalesRepsBySupervisorAsyncWithHttpInfo($supervisor_code)
    {
        $returnType = '\Advantage\Client\Model\SearchResultSalesRep';
        $request = $this->salesRepGetSalesRepsBySupervisorRequest($supervisor_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetSalesRepsBySupervisor'
     *
     * @param  string $supervisor_code Supervisor&#39;s sales rep code (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetSalesRepsBySupervisorRequest($supervisor_code)
    {
        // verify the required parameter 'supervisor_code' is set
        if ($supervisor_code === null || (is_array($supervisor_code) && count($supervisor_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supervisor_code when calling salesRepGetSalesRepsBySupervisor'
            );
        }

        $resourcePath = '/sales-reps/{supervisorCode}/sales-reps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($supervisor_code !== null) {
            $resourcePath = str_replace(
                '{' . 'supervisorCode' . '}',
                ObjectSerializer::toPathValue($supervisor_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepGetTeamCallStatistics
     *
     * Gets call statistics for a particular date range for a supervisor and all of their direct subordinates.
     *
     * @param  string $sales_rep_code Supervisor sales rep code for statistics range (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultCallStatistics
     */
    public function salesRepGetTeamCallStatistics($sales_rep_code, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        list($response) = $this->salesRepGetTeamCallStatisticsWithHttpInfo($sales_rep_code, $display_currency, $filter_begin_date, $filter_end_date, $filter_list_code, $filter_list_date);
        return $response;
    }

    /**
     * Operation salesRepGetTeamCallStatisticsWithHttpInfo
     *
     * Gets call statistics for a particular date range for a supervisor and all of their direct subordinates.
     *
     * @param  string $sales_rep_code Supervisor sales rep code for statistics range (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultCallStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepGetTeamCallStatisticsWithHttpInfo($sales_rep_code, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCallStatistics';
        $request = $this->salesRepGetTeamCallStatisticsRequest($sales_rep_code, $display_currency, $filter_begin_date, $filter_end_date, $filter_list_code, $filter_list_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultCallStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepGetTeamCallStatisticsAsync
     *
     * Gets call statistics for a particular date range for a supervisor and all of their direct subordinates.
     *
     * @param  string $sales_rep_code Supervisor sales rep code for statistics range (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetTeamCallStatisticsAsync($sales_rep_code, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        return $this->salesRepGetTeamCallStatisticsAsyncWithHttpInfo($sales_rep_code, $display_currency, $filter_begin_date, $filter_end_date, $filter_list_code, $filter_list_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepGetTeamCallStatisticsAsyncWithHttpInfo
     *
     * Gets call statistics for a particular date range for a supervisor and all of their direct subordinates.
     *
     * @param  string $sales_rep_code Supervisor sales rep code for statistics range (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepGetTeamCallStatisticsAsyncWithHttpInfo($sales_rep_code, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultCallStatistics';
        $request = $this->salesRepGetTeamCallStatisticsRequest($sales_rep_code, $display_currency, $filter_begin_date, $filter_end_date, $filter_list_code, $filter_list_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepGetTeamCallStatistics'
     *
     * @param  string $sales_rep_code Supervisor sales rep code for statistics range (required)
     * @param  string $display_currency The currency in which sales totals will be calculated (optional)
     * @param  \DateTime $filter_begin_date The earliest call date to include in statistics. (optional)
     * @param  \DateTime $filter_end_date The latest call date to include in statistics. (optional)
     * @param  string $filter_list_code List code of the list to limit the statistics to or null or empty string to compile  statistics across lists. (optional)
     * @param  \DateTime $filter_list_date The date associated with the call list (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepGetTeamCallStatisticsRequest($sales_rep_code, $display_currency = null, $filter_begin_date = null, $filter_end_date = null, $filter_list_code = null, $filter_list_date = null)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepGetTeamCallStatistics'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}/team-statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($display_currency !== null) {
            $queryParams['displayCurrency'] = ObjectSerializer::toQueryValue($display_currency);
        }
        // query params
        if ($filter_begin_date !== null) {
            $queryParams['filter.beginDate'] = ObjectSerializer::toQueryValue($filter_begin_date);
        }
        // query params
        if ($filter_end_date !== null) {
            $queryParams['filter.endDate'] = ObjectSerializer::toQueryValue($filter_end_date);
        }
        // query params
        if ($filter_list_code !== null) {
            $queryParams['filter.listCode'] = ObjectSerializer::toQueryValue($filter_list_code);
        }
        // query params
        if ($filter_list_date !== null) {
            $queryParams['filter.listDate'] = ObjectSerializer::toQueryValue($filter_list_date);
        }

        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepReassignCall
     *
     * Reassign one or more calls from one sales rep to another
     *
     * @param  \Advantage\Client\Model\ReassignCallRequest $reassign_call_request Information for reassigning one or more calls (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function salesRepReassignCall($reassign_call_request)
    {
        $this->salesRepReassignCallWithHttpInfo($reassign_call_request);
    }

    /**
     * Operation salesRepReassignCallWithHttpInfo
     *
     * Reassign one or more calls from one sales rep to another
     *
     * @param  \Advantage\Client\Model\ReassignCallRequest $reassign_call_request Information for reassigning one or more calls (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepReassignCallWithHttpInfo($reassign_call_request)
    {
        $returnType = '';
        $request = $this->salesRepReassignCallRequest($reassign_call_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepReassignCallAsync
     *
     * Reassign one or more calls from one sales rep to another
     *
     * @param  \Advantage\Client\Model\ReassignCallRequest $reassign_call_request Information for reassigning one or more calls (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepReassignCallAsync($reassign_call_request)
    {
        return $this->salesRepReassignCallAsyncWithHttpInfo($reassign_call_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepReassignCallAsyncWithHttpInfo
     *
     * Reassign one or more calls from one sales rep to another
     *
     * @param  \Advantage\Client\Model\ReassignCallRequest $reassign_call_request Information for reassigning one or more calls (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepReassignCallAsyncWithHttpInfo($reassign_call_request)
    {
        $returnType = '';
        $request = $this->salesRepReassignCallRequest($reassign_call_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepReassignCall'
     *
     * @param  \Advantage\Client\Model\ReassignCallRequest $reassign_call_request Information for reassigning one or more calls (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepReassignCallRequest($reassign_call_request)
    {
        // verify the required parameter 'reassign_call_request' is set
        if ($reassign_call_request === null || (is_array($reassign_call_request) && count($reassign_call_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reassign_call_request when calling salesRepReassignCall'
            );
        }

        $resourcePath = '/sales-reps/reassign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($reassign_call_request)) {
            $_tempBody = $reassign_call_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepRemove
     *
     * Removes a Sales Rep
     *
     * @param  string $sales_rep_code The Number that identifies the Sales Rep to be deleted. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function salesRepRemove($sales_rep_code)
    {
        $this->salesRepRemoveWithHttpInfo($sales_rep_code);
    }

    /**
     * Operation salesRepRemoveWithHttpInfo
     *
     * Removes a Sales Rep
     *
     * @param  string $sales_rep_code The Number that identifies the Sales Rep to be deleted. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepRemoveWithHttpInfo($sales_rep_code)
    {
        $returnType = '';
        $request = $this->salesRepRemoveRequest($sales_rep_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepRemoveAsync
     *
     * Removes a Sales Rep
     *
     * @param  string $sales_rep_code The Number that identifies the Sales Rep to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepRemoveAsync($sales_rep_code)
    {
        return $this->salesRepRemoveAsyncWithHttpInfo($sales_rep_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepRemoveAsyncWithHttpInfo
     *
     * Removes a Sales Rep
     *
     * @param  string $sales_rep_code The Number that identifies the Sales Rep to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepRemoveAsyncWithHttpInfo($sales_rep_code)
    {
        $returnType = '';
        $request = $this->salesRepRemoveRequest($sales_rep_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepRemove'
     *
     * @param  string $sales_rep_code The Number that identifies the Sales Rep to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepRemoveRequest($sales_rep_code)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepRemove'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepUpdate
     *
     * Update an existing Sales Rep
     *
     * @param  string $sales_rep_code Sales Rep Number of the Sales Rep to be Updated (required)
     * @param  \Advantage\Client\Model\SalesRepUpdateRequest $sales_rep_update_request Information to update the Sales Rep with (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SalesRep
     */
    public function salesRepUpdate($sales_rep_code, $sales_rep_update_request)
    {
        list($response) = $this->salesRepUpdateWithHttpInfo($sales_rep_code, $sales_rep_update_request);
        return $response;
    }

    /**
     * Operation salesRepUpdateWithHttpInfo
     *
     * Update an existing Sales Rep
     *
     * @param  string $sales_rep_code Sales Rep Number of the Sales Rep to be Updated (required)
     * @param  \Advantage\Client\Model\SalesRepUpdateRequest $sales_rep_update_request Information to update the Sales Rep with (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SalesRep, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepUpdateWithHttpInfo($sales_rep_code, $sales_rep_update_request)
    {
        $returnType = '\Advantage\Client\Model\SalesRep';
        $request = $this->salesRepUpdateRequest($sales_rep_code, $sales_rep_update_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SalesRep',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepUpdateAsync
     *
     * Update an existing Sales Rep
     *
     * @param  string $sales_rep_code Sales Rep Number of the Sales Rep to be Updated (required)
     * @param  \Advantage\Client\Model\SalesRepUpdateRequest $sales_rep_update_request Information to update the Sales Rep with (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepUpdateAsync($sales_rep_code, $sales_rep_update_request)
    {
        return $this->salesRepUpdateAsyncWithHttpInfo($sales_rep_code, $sales_rep_update_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepUpdateAsyncWithHttpInfo
     *
     * Update an existing Sales Rep
     *
     * @param  string $sales_rep_code Sales Rep Number of the Sales Rep to be Updated (required)
     * @param  \Advantage\Client\Model\SalesRepUpdateRequest $sales_rep_update_request Information to update the Sales Rep with (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepUpdateAsyncWithHttpInfo($sales_rep_code, $sales_rep_update_request)
    {
        $returnType = '\Advantage\Client\Model\SalesRep';
        $request = $this->salesRepUpdateRequest($sales_rep_code, $sales_rep_update_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepUpdate'
     *
     * @param  string $sales_rep_code Sales Rep Number of the Sales Rep to be Updated (required)
     * @param  \Advantage\Client\Model\SalesRepUpdateRequest $sales_rep_update_request Information to update the Sales Rep with (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepUpdateRequest($sales_rep_code, $sales_rep_update_request)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepUpdate'
            );
        }
        // verify the required parameter 'sales_rep_update_request' is set
        if ($sales_rep_update_request === null || (is_array($sales_rep_update_request) && count($sales_rep_update_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_update_request when calling salesRepUpdate'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($sales_rep_update_request)) {
            $_tempBody = $sales_rep_update_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation salesRepUpdateCallCount
     *
     * Updates call count for a sales rep on a particular call list
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  int $quantity Number of calls to change (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function salesRepUpdateCallCount($sales_rep_code, $list_id, $list_date, $quantity)
    {
        $this->salesRepUpdateCallCountWithHttpInfo($sales_rep_code, $list_id, $list_date, $quantity);
    }

    /**
     * Operation salesRepUpdateCallCountWithHttpInfo
     *
     * Updates call count for a sales rep on a particular call list
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  int $quantity Number of calls to change (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function salesRepUpdateCallCountWithHttpInfo($sales_rep_code, $list_id, $list_date, $quantity)
    {
        $returnType = '';
        $request = $this->salesRepUpdateCallCountRequest($sales_rep_code, $list_id, $list_date, $quantity);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation salesRepUpdateCallCountAsync
     *
     * Updates call count for a sales rep on a particular call list
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  int $quantity Number of calls to change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepUpdateCallCountAsync($sales_rep_code, $list_id, $list_date, $quantity)
    {
        return $this->salesRepUpdateCallCountAsyncWithHttpInfo($sales_rep_code, $list_id, $list_date, $quantity)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation salesRepUpdateCallCountAsyncWithHttpInfo
     *
     * Updates call count for a sales rep on a particular call list
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  int $quantity Number of calls to change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function salesRepUpdateCallCountAsyncWithHttpInfo($sales_rep_code, $list_id, $list_date, $quantity)
    {
        $returnType = '';
        $request = $this->salesRepUpdateCallCountRequest($sales_rep_code, $list_id, $list_date, $quantity);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'salesRepUpdateCallCount'
     *
     * @param  string $sales_rep_code Sales representative code for a given sales representative (required)
     * @param  string $list_id List Id (required)
     * @param  \DateTime $list_date List Date (required)
     * @param  int $quantity Number of calls to change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function salesRepUpdateCallCountRequest($sales_rep_code, $list_id, $list_date, $quantity)
    {
        // verify the required parameter 'sales_rep_code' is set
        if ($sales_rep_code === null || (is_array($sales_rep_code) && count($sales_rep_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_rep_code when calling salesRepUpdateCallCount'
            );
        }
        // verify the required parameter 'list_id' is set
        if ($list_id === null || (is_array($list_id) && count($list_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $list_id when calling salesRepUpdateCallCount'
            );
        }
        // verify the required parameter 'list_date' is set
        if ($list_date === null || (is_array($list_date) && count($list_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $list_date when calling salesRepUpdateCallCount'
            );
        }
        // verify the required parameter 'quantity' is set
        if ($quantity === null || (is_array($quantity) && count($quantity) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $quantity when calling salesRepUpdateCallCount'
            );
        }

        $resourcePath = '/sales-reps/{salesRepCode}/{listId}/{listDate}/{quantity}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sales_rep_code !== null) {
            $resourcePath = str_replace(
                '{' . 'salesRepCode' . '}',
                ObjectSerializer::toPathValue($sales_rep_code),
                $resourcePath
            );
        }
        // path params
        if ($list_id !== null) {
            $resourcePath = str_replace(
                '{' . 'listId' . '}',
                ObjectSerializer::toPathValue($list_id),
                $resourcePath
            );
        }
        // path params
        if ($list_date !== null) {
            $resourcePath = str_replace(
                '{' . 'listDate' . '}',
                ObjectSerializer::toPathValue($list_date),
                $resourcePath
            );
        }
        // path params
        if ($quantity !== null) {
            $resourcePath = str_replace(
                '{' . 'quantity' . '}',
                ObjectSerializer::toPathValue($quantity),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
