<?php
/**
 * ProductApi
 * PHP version 5
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Advantage.Rest.Services
 *
 * No description provided (generated by Advantage Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Advantage Codegen version: 2.4.20
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Advantage\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Advantage\Client\ApiException;
use Advantage\Client\Configuration;
use Advantage\Client\HeaderSelector;
use Advantage\Client\ObjectSerializer;

/**
 * ProductApi Class Doc Comment
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ProductApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation productGet
     *
     * Get information for a given product.
     *
     * @param  string $item_number The item number of the desired product. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\Product
     */
    public function productGet($item_number)
    {
        list($response) = $this->productGetWithHttpInfo($item_number);
        return $response;
    }

    /**
     * Operation productGetWithHttpInfo
     *
     * Get information for a given product.
     *
     * @param  string $item_number The item number of the desired product. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetWithHttpInfo($item_number)
    {
        $returnType = '\Advantage\Client\Model\Product';
        $request = $this->productGetRequest($item_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetAsync
     *
     * Get information for a given product.
     *
     * @param  string $item_number The item number of the desired product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetAsync($item_number)
    {
        return $this->productGetAsyncWithHttpInfo($item_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetAsyncWithHttpInfo
     *
     * Get information for a given product.
     *
     * @param  string $item_number The item number of the desired product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetAsyncWithHttpInfo($item_number)
    {
        $returnType = '\Advantage\Client\Model\Product';
        $request = $this->productGetRequest($item_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGet'
     *
     * @param  string $item_number The item number of the desired product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetRequest($item_number)
    {
        // verify the required parameter 'item_number' is set
        if ($item_number === null || (is_array($item_number) && count($item_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_number when calling productGet'
            );
        }

        $resourcePath = '/products/{itemNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_number !== null) {
            $resourcePath = str_replace(
                '{' . 'itemNumber' . '}',
                ObjectSerializer::toPathValue($item_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetByAuthor
     *
     * Get information for all products by the given author.  This is a preliminary API, subject to change.
     *
     * @param  string $author The name of an Author. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultProduct
     */
    public function productGetByAuthor($author, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->productGetByAuthorWithHttpInfo($author, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation productGetByAuthorWithHttpInfo
     *
     * Get information for all products by the given author.  This is a preliminary API, subject to change.
     *
     * @param  string $author The name of an Author. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetByAuthorWithHttpInfo($author, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetByAuthorRequest($author, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetByAuthorAsync
     *
     * Get information for all products by the given author.  This is a preliminary API, subject to change.
     *
     * @param  string $author The name of an Author. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetByAuthorAsync($author, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        return $this->productGetByAuthorAsyncWithHttpInfo($author, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetByAuthorAsyncWithHttpInfo
     *
     * Get information for all products by the given author.  This is a preliminary API, subject to change.
     *
     * @param  string $author The name of an Author. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetByAuthorAsyncWithHttpInfo($author, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetByAuthorRequest($author, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetByAuthor'
     *
     * @param  string $author The name of an Author. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetByAuthorRequest($author, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'author' is set
        if ($author === null || (is_array($author) && count($author) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $author when calling productGetByAuthor'
            );
        }

        $resourcePath = '/products/by-author/{author}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter_match_type !== null) {
            $queryParams['filter.matchType'] = ObjectSerializer::toQueryValue($filter_match_type);
        }
        // query params
        if ($filter_order_by !== null) {
            $queryParams['filter.orderBy'] = ObjectSerializer::toQueryValue($filter_order_by);
        }
        // query params
        if ($filter_subject_tree_level_id !== null) {
            $queryParams['filter.subjectTreeLevelId'] = ObjectSerializer::toQueryValue($filter_subject_tree_level_id);
        }
        // query params
        if ($filter_sales_analysis_category_code !== null) {
            $queryParams['filter.salesAnalysisCategoryCode'] = ObjectSerializer::toQueryValue($filter_sales_analysis_category_code);
        }
        // query params
        if ($filter_owning_organization_code !== null) {
            $queryParams['filter.owningOrganizationCode'] = ObjectSerializer::toQueryValue($filter_owning_organization_code);
        }
        // query params
        if (is_array($filter_product_types)) {
            $queryParams['filter.productTypes'] = $filter_product_types;
        } else
        if ($filter_product_types !== null) {
            $queryParams['filter.productTypes'] = ObjectSerializer::toQueryValue($filter_product_types);
        }
        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($author !== null) {
            $resourcePath = str_replace(
                '{' . 'author' . '}',
                ObjectSerializer::toPathValue($author),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetByIsbn
     *
     * Gets information for a product, given an ISBN-13.  This is a preliminary API, subject to change.
     *
     * @param  string $isbn The ISBN-13 of the product for which to retrieve information. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\Product
     */
    public function productGetByIsbn($isbn)
    {
        list($response) = $this->productGetByIsbnWithHttpInfo($isbn);
        return $response;
    }

    /**
     * Operation productGetByIsbnWithHttpInfo
     *
     * Gets information for a product, given an ISBN-13.  This is a preliminary API, subject to change.
     *
     * @param  string $isbn The ISBN-13 of the product for which to retrieve information. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetByIsbnWithHttpInfo($isbn)
    {
        $returnType = '\Advantage\Client\Model\Product';
        $request = $this->productGetByIsbnRequest($isbn);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetByIsbnAsync
     *
     * Gets information for a product, given an ISBN-13.  This is a preliminary API, subject to change.
     *
     * @param  string $isbn The ISBN-13 of the product for which to retrieve information. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetByIsbnAsync($isbn)
    {
        return $this->productGetByIsbnAsyncWithHttpInfo($isbn)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetByIsbnAsyncWithHttpInfo
     *
     * Gets information for a product, given an ISBN-13.  This is a preliminary API, subject to change.
     *
     * @param  string $isbn The ISBN-13 of the product for which to retrieve information. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetByIsbnAsyncWithHttpInfo($isbn)
    {
        $returnType = '\Advantage\Client\Model\Product';
        $request = $this->productGetByIsbnRequest($isbn);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetByIsbn'
     *
     * @param  string $isbn The ISBN-13 of the product for which to retrieve information. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetByIsbnRequest($isbn)
    {
        // verify the required parameter 'isbn' is set
        if ($isbn === null || (is_array($isbn) && count($isbn) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $isbn when calling productGetByIsbn'
            );
        }

        $resourcePath = '/products/by-isbn13/{isbn}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($isbn !== null) {
            $resourcePath = str_replace(
                '{' . 'isbn' . '}',
                ObjectSerializer::toPathValue($isbn),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetByKeyword
     *
     * Get information for all products with the given keyword.  This is a preliminary API, subject to change.
     *
     * @param  string $keyword The keyword to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultProduct
     */
    public function productGetByKeyword($keyword, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->productGetByKeywordWithHttpInfo($keyword, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation productGetByKeywordWithHttpInfo
     *
     * Get information for all products with the given keyword.  This is a preliminary API, subject to change.
     *
     * @param  string $keyword The keyword to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetByKeywordWithHttpInfo($keyword, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetByKeywordRequest($keyword, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetByKeywordAsync
     *
     * Get information for all products with the given keyword.  This is a preliminary API, subject to change.
     *
     * @param  string $keyword The keyword to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetByKeywordAsync($keyword, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        return $this->productGetByKeywordAsyncWithHttpInfo($keyword, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetByKeywordAsyncWithHttpInfo
     *
     * Get information for all products with the given keyword.  This is a preliminary API, subject to change.
     *
     * @param  string $keyword The keyword to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetByKeywordAsyncWithHttpInfo($keyword, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetByKeywordRequest($keyword, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetByKeyword'
     *
     * @param  string $keyword The keyword to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetByKeywordRequest($keyword, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'keyword' is set
        if ($keyword === null || (is_array($keyword) && count($keyword) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keyword when calling productGetByKeyword'
            );
        }

        $resourcePath = '/products/by-keyword/{keyword}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter_match_type !== null) {
            $queryParams['filter.matchType'] = ObjectSerializer::toQueryValue($filter_match_type);
        }
        // query params
        if ($filter_order_by !== null) {
            $queryParams['filter.orderBy'] = ObjectSerializer::toQueryValue($filter_order_by);
        }
        // query params
        if ($filter_subject_tree_level_id !== null) {
            $queryParams['filter.subjectTreeLevelId'] = ObjectSerializer::toQueryValue($filter_subject_tree_level_id);
        }
        // query params
        if ($filter_sales_analysis_category_code !== null) {
            $queryParams['filter.salesAnalysisCategoryCode'] = ObjectSerializer::toQueryValue($filter_sales_analysis_category_code);
        }
        // query params
        if ($filter_owning_organization_code !== null) {
            $queryParams['filter.owningOrganizationCode'] = ObjectSerializer::toQueryValue($filter_owning_organization_code);
        }
        // query params
        if (is_array($filter_product_types)) {
            $queryParams['filter.productTypes'] = $filter_product_types;
        } else
        if ($filter_product_types !== null) {
            $queryParams['filter.productTypes'] = ObjectSerializer::toQueryValue($filter_product_types);
        }
        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($keyword !== null) {
            $resourcePath = str_replace(
                '{' . 'keyword' . '}',
                ObjectSerializer::toPathValue($keyword),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetBySearch
     *
     * Get information for all products with the given search term.  This is a preliminary API, subject to change.
     *
     * @param  string $search The search term to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultProduct
     */
    public function productGetBySearch($search, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->productGetBySearchWithHttpInfo($search, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation productGetBySearchWithHttpInfo
     *
     * Get information for all products with the given search term.  This is a preliminary API, subject to change.
     *
     * @param  string $search The search term to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetBySearchWithHttpInfo($search, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetBySearchRequest($search, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetBySearchAsync
     *
     * Get information for all products with the given search term.  This is a preliminary API, subject to change.
     *
     * @param  string $search The search term to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetBySearchAsync($search, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        return $this->productGetBySearchAsyncWithHttpInfo($search, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetBySearchAsyncWithHttpInfo
     *
     * Get information for all products with the given search term.  This is a preliminary API, subject to change.
     *
     * @param  string $search The search term to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetBySearchAsyncWithHttpInfo($search, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetBySearchRequest($search, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetBySearch'
     *
     * @param  string $search The search term to use when searching for products. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetBySearchRequest($search, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'search' is set
        if ($search === null || (is_array($search) && count($search) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search when calling productGetBySearch'
            );
        }

        $resourcePath = '/products/by-search/{search}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter_match_type !== null) {
            $queryParams['filter.matchType'] = ObjectSerializer::toQueryValue($filter_match_type);
        }
        // query params
        if ($filter_order_by !== null) {
            $queryParams['filter.orderBy'] = ObjectSerializer::toQueryValue($filter_order_by);
        }
        // query params
        if ($filter_subject_tree_level_id !== null) {
            $queryParams['filter.subjectTreeLevelId'] = ObjectSerializer::toQueryValue($filter_subject_tree_level_id);
        }
        // query params
        if ($filter_sales_analysis_category_code !== null) {
            $queryParams['filter.salesAnalysisCategoryCode'] = ObjectSerializer::toQueryValue($filter_sales_analysis_category_code);
        }
        // query params
        if ($filter_owning_organization_code !== null) {
            $queryParams['filter.owningOrganizationCode'] = ObjectSerializer::toQueryValue($filter_owning_organization_code);
        }
        // query params
        if (is_array($filter_product_types)) {
            $queryParams['filter.productTypes'] = $filter_product_types;
        } else
        if ($filter_product_types !== null) {
            $queryParams['filter.productTypes'] = ObjectSerializer::toQueryValue($filter_product_types);
        }
        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($search !== null) {
            $resourcePath = str_replace(
                '{' . 'search' . '}',
                ObjectSerializer::toPathValue($search),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetBySubjectTree
     *
     * Get information for all products for the given subject tree.
     *
     * @param  string $subject_tree_level_id The level ID of the subject tree for which to retrieve products. (required)
     * @param  string $order_by Options for how to order the search results. (optional)
     * @param  string $highlighted Options for how to filter the search results. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultProduct
     */
    public function productGetBySubjectTree($subject_tree_level_id, $order_by = null, $highlighted = null)
    {
        list($response) = $this->productGetBySubjectTreeWithHttpInfo($subject_tree_level_id, $order_by, $highlighted);
        return $response;
    }

    /**
     * Operation productGetBySubjectTreeWithHttpInfo
     *
     * Get information for all products for the given subject tree.
     *
     * @param  string $subject_tree_level_id The level ID of the subject tree for which to retrieve products. (required)
     * @param  string $order_by Options for how to order the search results. (optional)
     * @param  string $highlighted Options for how to filter the search results. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetBySubjectTreeWithHttpInfo($subject_tree_level_id, $order_by = null, $highlighted = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetBySubjectTreeRequest($subject_tree_level_id, $order_by, $highlighted);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetBySubjectTreeAsync
     *
     * Get information for all products for the given subject tree.
     *
     * @param  string $subject_tree_level_id The level ID of the subject tree for which to retrieve products. (required)
     * @param  string $order_by Options for how to order the search results. (optional)
     * @param  string $highlighted Options for how to filter the search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetBySubjectTreeAsync($subject_tree_level_id, $order_by = null, $highlighted = null)
    {
        return $this->productGetBySubjectTreeAsyncWithHttpInfo($subject_tree_level_id, $order_by, $highlighted)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetBySubjectTreeAsyncWithHttpInfo
     *
     * Get information for all products for the given subject tree.
     *
     * @param  string $subject_tree_level_id The level ID of the subject tree for which to retrieve products. (required)
     * @param  string $order_by Options for how to order the search results. (optional)
     * @param  string $highlighted Options for how to filter the search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetBySubjectTreeAsyncWithHttpInfo($subject_tree_level_id, $order_by = null, $highlighted = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetBySubjectTreeRequest($subject_tree_level_id, $order_by, $highlighted);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetBySubjectTree'
     *
     * @param  string $subject_tree_level_id The level ID of the subject tree for which to retrieve products. (required)
     * @param  string $order_by Options for how to order the search results. (optional)
     * @param  string $highlighted Options for how to filter the search results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetBySubjectTreeRequest($subject_tree_level_id, $order_by = null, $highlighted = null)
    {
        // verify the required parameter 'subject_tree_level_id' is set
        if ($subject_tree_level_id === null || (is_array($subject_tree_level_id) && count($subject_tree_level_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subject_tree_level_id when calling productGetBySubjectTree'
            );
        }

        $resourcePath = '/product-catalogs/{subjectTreeLevelId}/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($highlighted !== null) {
            $queryParams['highlighted'] = ObjectSerializer::toQueryValue($highlighted);
        }

        // path params
        if ($subject_tree_level_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subjectTreeLevelId' . '}',
                ObjectSerializer::toPathValue($subject_tree_level_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetByTitle
     *
     * Get information for all products with the given title.  This is a preliminary API, subject to change.
     *
     * @param  string $title The title of the products to retrieve. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultProduct
     */
    public function productGetByTitle($title, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->productGetByTitleWithHttpInfo($title, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation productGetByTitleWithHttpInfo
     *
     * Get information for all products with the given title.  This is a preliminary API, subject to change.
     *
     * @param  string $title The title of the products to retrieve. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetByTitleWithHttpInfo($title, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetByTitleRequest($title, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetByTitleAsync
     *
     * Get information for all products with the given title.  This is a preliminary API, subject to change.
     *
     * @param  string $title The title of the products to retrieve. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetByTitleAsync($title, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        return $this->productGetByTitleAsyncWithHttpInfo($title, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetByTitleAsyncWithHttpInfo
     *
     * Get information for all products with the given title.  This is a preliminary API, subject to change.
     *
     * @param  string $title The title of the products to retrieve. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetByTitleAsyncWithHttpInfo($title, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProduct';
        $request = $this->productGetByTitleRequest($title, $filter_match_type, $filter_order_by, $filter_subject_tree_level_id, $filter_sales_analysis_category_code, $filter_owning_organization_code, $filter_product_types, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetByTitle'
     *
     * @param  string $title The title of the products to retrieve. (required)
     * @param  string $filter_match_type The type of matching to use for the search. (optional)
     * @param  string $filter_order_by The type of ordering on the search. (optional)
     * @param  string $filter_subject_tree_level_id The ID of the subject tree level to search. (optional)
     * @param  string $filter_sales_analysis_category_code Restrict search to products within the given sales analysis code (or blank). (optional)
     * @param  string $filter_owning_organization_code Owning organizations to filter by. (optional)
     * @param  string[] $filter_product_types List of product types to include in search. If null, all product types are included. (optional)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetByTitleRequest($title, $filter_match_type = null, $filter_order_by = null, $filter_subject_tree_level_id = null, $filter_sales_analysis_category_code = null, $filter_owning_organization_code = null, $filter_product_types = null, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling productGetByTitle'
            );
        }

        $resourcePath = '/products/by-title/{title}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter_match_type !== null) {
            $queryParams['filter.matchType'] = ObjectSerializer::toQueryValue($filter_match_type);
        }
        // query params
        if ($filter_order_by !== null) {
            $queryParams['filter.orderBy'] = ObjectSerializer::toQueryValue($filter_order_by);
        }
        // query params
        if ($filter_subject_tree_level_id !== null) {
            $queryParams['filter.subjectTreeLevelId'] = ObjectSerializer::toQueryValue($filter_subject_tree_level_id);
        }
        // query params
        if ($filter_sales_analysis_category_code !== null) {
            $queryParams['filter.salesAnalysisCategoryCode'] = ObjectSerializer::toQueryValue($filter_sales_analysis_category_code);
        }
        // query params
        if ($filter_owning_organization_code !== null) {
            $queryParams['filter.owningOrganizationCode'] = ObjectSerializer::toQueryValue($filter_owning_organization_code);
        }
        // query params
        if (is_array($filter_product_types)) {
            $queryParams['filter.productTypes'] = $filter_product_types;
        } else
        if ($filter_product_types !== null) {
            $queryParams['filter.productTypes'] = ObjectSerializer::toQueryValue($filter_product_types);
        }
        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($title !== null) {
            $resourcePath = str_replace(
                '{' . 'title' . '}',
                ObjectSerializer::toPathValue($title),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetGiftMessagesSupport
     *
     * Checks to see if gift messages are supported for the given item and customer type.
     *
     * @param  string $item_number Item Number (required)
     * @param  string $customer_type Customer Type Code (required)
     * @param  bool $different_customers True if the bill-to and ship-to customers are different. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\GiftMessageSupportResponse
     */
    public function productGetGiftMessagesSupport($item_number, $customer_type, $different_customers)
    {
        list($response) = $this->productGetGiftMessagesSupportWithHttpInfo($item_number, $customer_type, $different_customers);
        return $response;
    }

    /**
     * Operation productGetGiftMessagesSupportWithHttpInfo
     *
     * Checks to see if gift messages are supported for the given item and customer type.
     *
     * @param  string $item_number Item Number (required)
     * @param  string $customer_type Customer Type Code (required)
     * @param  bool $different_customers True if the bill-to and ship-to customers are different. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\GiftMessageSupportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetGiftMessagesSupportWithHttpInfo($item_number, $customer_type, $different_customers)
    {
        $returnType = '\Advantage\Client\Model\GiftMessageSupportResponse';
        $request = $this->productGetGiftMessagesSupportRequest($item_number, $customer_type, $different_customers);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\GiftMessageSupportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetGiftMessagesSupportAsync
     *
     * Checks to see if gift messages are supported for the given item and customer type.
     *
     * @param  string $item_number Item Number (required)
     * @param  string $customer_type Customer Type Code (required)
     * @param  bool $different_customers True if the bill-to and ship-to customers are different. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetGiftMessagesSupportAsync($item_number, $customer_type, $different_customers)
    {
        return $this->productGetGiftMessagesSupportAsyncWithHttpInfo($item_number, $customer_type, $different_customers)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetGiftMessagesSupportAsyncWithHttpInfo
     *
     * Checks to see if gift messages are supported for the given item and customer type.
     *
     * @param  string $item_number Item Number (required)
     * @param  string $customer_type Customer Type Code (required)
     * @param  bool $different_customers True if the bill-to and ship-to customers are different. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetGiftMessagesSupportAsyncWithHttpInfo($item_number, $customer_type, $different_customers)
    {
        $returnType = '\Advantage\Client\Model\GiftMessageSupportResponse';
        $request = $this->productGetGiftMessagesSupportRequest($item_number, $customer_type, $different_customers);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetGiftMessagesSupport'
     *
     * @param  string $item_number Item Number (required)
     * @param  string $customer_type Customer Type Code (required)
     * @param  bool $different_customers True if the bill-to and ship-to customers are different. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetGiftMessagesSupportRequest($item_number, $customer_type, $different_customers)
    {
        // verify the required parameter 'item_number' is set
        if ($item_number === null || (is_array($item_number) && count($item_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_number when calling productGetGiftMessagesSupport'
            );
        }
        // verify the required parameter 'customer_type' is set
        if ($customer_type === null || (is_array($customer_type) && count($customer_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_type when calling productGetGiftMessagesSupport'
            );
        }
        // verify the required parameter 'different_customers' is set
        if ($different_customers === null || (is_array($different_customers) && count($different_customers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $different_customers when calling productGetGiftMessagesSupport'
            );
        }

        $resourcePath = '/products/{itemNumber}/{customerType}/supports-gift-messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($different_customers !== null) {
            $queryParams['differentCustomers'] = ObjectSerializer::toQueryValue($different_customers);
        }

        // path params
        if ($item_number !== null) {
            $resourcePath = str_replace(
                '{' . 'itemNumber' . '}',
                ObjectSerializer::toPathValue($item_number),
                $resourcePath
            );
        }
        // path params
        if ($customer_type !== null) {
            $resourcePath = str_replace(
                '{' . 'customerType' . '}',
                ObjectSerializer::toPathValue($customer_type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetOnixData
     *
     * Gets ONIX data on a product.
     *
     * @param  string $item_number The item number of the desired product to grab ONIX data from. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function productGetOnixData($item_number)
    {
        list($response) = $this->productGetOnixDataWithHttpInfo($item_number);
        return $response;
    }

    /**
     * Operation productGetOnixDataWithHttpInfo
     *
     * Gets ONIX data on a product.
     *
     * @param  string $item_number The item number of the desired product to grab ONIX data from. (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetOnixDataWithHttpInfo($item_number)
    {
        $returnType = 'object';
        $request = $this->productGetOnixDataRequest($item_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetOnixDataAsync
     *
     * Gets ONIX data on a product.
     *
     * @param  string $item_number The item number of the desired product to grab ONIX data from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetOnixDataAsync($item_number)
    {
        return $this->productGetOnixDataAsyncWithHttpInfo($item_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetOnixDataAsyncWithHttpInfo
     *
     * Gets ONIX data on a product.
     *
     * @param  string $item_number The item number of the desired product to grab ONIX data from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetOnixDataAsyncWithHttpInfo($item_number)
    {
        $returnType = 'object';
        $request = $this->productGetOnixDataRequest($item_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetOnixData'
     *
     * @param  string $item_number The item number of the desired product to grab ONIX data from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetOnixDataRequest($item_number)
    {
        // verify the required parameter 'item_number' is set
        if ($item_number === null || (is_array($item_number) && count($item_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_number when calling productGetOnixData'
            );
        }

        $resourcePath = '/products/{itemNumber}/onix-3.0';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_number !== null) {
            $resourcePath = str_replace(
                '{' . 'itemNumber' . '}',
                ObjectSerializer::toPathValue($item_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetPrice
     *
     * Calculates what the price would be on the order line as if the particular customer   passed in ordered the item and used the passed in promotion
     *
     * @param  string $item_number Item number to make an order off on. (required)
     * @param  string $price_code Optional price code to use for price calculation. (required)
     * @param  string $order_line_forecast_customer_number (Required) Customer Number of the customer that will be making the order. This customer  will serve as both the billing and ship to customer. (optional)
     * @param  string $order_line_forecast_promotion_code (Required) Promotion Code that will be used on the order line. (optional)
     * @param  string $order_line_forecast_billing_currency_code (Required) The currency that will be used on the order line. (optional)
     * @param  bool $order_line_forecast_different_ship_to (Optional) If true, the order forecaster will use a different customer as the ship to customer. (optional)
     * @param  int $order_line_forecast_quantity (Optional) The quantity of the item that will be ordered. Defaults to 1. (optional)
     * @param  string $order_line_forecast_promotion_choice_code (Optional) Promotion Choice that will be used on the order line. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\ItemPrice
     */
    public function productGetPrice($item_number, $price_code, $order_line_forecast_customer_number = null, $order_line_forecast_promotion_code = null, $order_line_forecast_billing_currency_code = null, $order_line_forecast_different_ship_to = null, $order_line_forecast_quantity = null, $order_line_forecast_promotion_choice_code = null)
    {
        list($response) = $this->productGetPriceWithHttpInfo($item_number, $price_code, $order_line_forecast_customer_number, $order_line_forecast_promotion_code, $order_line_forecast_billing_currency_code, $order_line_forecast_different_ship_to, $order_line_forecast_quantity, $order_line_forecast_promotion_choice_code);
        return $response;
    }

    /**
     * Operation productGetPriceWithHttpInfo
     *
     * Calculates what the price would be on the order line as if the particular customer   passed in ordered the item and used the passed in promotion
     *
     * @param  string $item_number Item number to make an order off on. (required)
     * @param  string $price_code Optional price code to use for price calculation. (required)
     * @param  string $order_line_forecast_customer_number (Required) Customer Number of the customer that will be making the order. This customer  will serve as both the billing and ship to customer. (optional)
     * @param  string $order_line_forecast_promotion_code (Required) Promotion Code that will be used on the order line. (optional)
     * @param  string $order_line_forecast_billing_currency_code (Required) The currency that will be used on the order line. (optional)
     * @param  bool $order_line_forecast_different_ship_to (Optional) If true, the order forecaster will use a different customer as the ship to customer. (optional)
     * @param  int $order_line_forecast_quantity (Optional) The quantity of the item that will be ordered. Defaults to 1. (optional)
     * @param  string $order_line_forecast_promotion_choice_code (Optional) Promotion Choice that will be used on the order line. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\ItemPrice, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetPriceWithHttpInfo($item_number, $price_code, $order_line_forecast_customer_number = null, $order_line_forecast_promotion_code = null, $order_line_forecast_billing_currency_code = null, $order_line_forecast_different_ship_to = null, $order_line_forecast_quantity = null, $order_line_forecast_promotion_choice_code = null)
    {
        $returnType = '\Advantage\Client\Model\ItemPrice';
        $request = $this->productGetPriceRequest($item_number, $price_code, $order_line_forecast_customer_number, $order_line_forecast_promotion_code, $order_line_forecast_billing_currency_code, $order_line_forecast_different_ship_to, $order_line_forecast_quantity, $order_line_forecast_promotion_choice_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\ItemPrice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetPriceAsync
     *
     * Calculates what the price would be on the order line as if the particular customer   passed in ordered the item and used the passed in promotion
     *
     * @param  string $item_number Item number to make an order off on. (required)
     * @param  string $price_code Optional price code to use for price calculation. (required)
     * @param  string $order_line_forecast_customer_number (Required) Customer Number of the customer that will be making the order. This customer  will serve as both the billing and ship to customer. (optional)
     * @param  string $order_line_forecast_promotion_code (Required) Promotion Code that will be used on the order line. (optional)
     * @param  string $order_line_forecast_billing_currency_code (Required) The currency that will be used on the order line. (optional)
     * @param  bool $order_line_forecast_different_ship_to (Optional) If true, the order forecaster will use a different customer as the ship to customer. (optional)
     * @param  int $order_line_forecast_quantity (Optional) The quantity of the item that will be ordered. Defaults to 1. (optional)
     * @param  string $order_line_forecast_promotion_choice_code (Optional) Promotion Choice that will be used on the order line. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetPriceAsync($item_number, $price_code, $order_line_forecast_customer_number = null, $order_line_forecast_promotion_code = null, $order_line_forecast_billing_currency_code = null, $order_line_forecast_different_ship_to = null, $order_line_forecast_quantity = null, $order_line_forecast_promotion_choice_code = null)
    {
        return $this->productGetPriceAsyncWithHttpInfo($item_number, $price_code, $order_line_forecast_customer_number, $order_line_forecast_promotion_code, $order_line_forecast_billing_currency_code, $order_line_forecast_different_ship_to, $order_line_forecast_quantity, $order_line_forecast_promotion_choice_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetPriceAsyncWithHttpInfo
     *
     * Calculates what the price would be on the order line as if the particular customer   passed in ordered the item and used the passed in promotion
     *
     * @param  string $item_number Item number to make an order off on. (required)
     * @param  string $price_code Optional price code to use for price calculation. (required)
     * @param  string $order_line_forecast_customer_number (Required) Customer Number of the customer that will be making the order. This customer  will serve as both the billing and ship to customer. (optional)
     * @param  string $order_line_forecast_promotion_code (Required) Promotion Code that will be used on the order line. (optional)
     * @param  string $order_line_forecast_billing_currency_code (Required) The currency that will be used on the order line. (optional)
     * @param  bool $order_line_forecast_different_ship_to (Optional) If true, the order forecaster will use a different customer as the ship to customer. (optional)
     * @param  int $order_line_forecast_quantity (Optional) The quantity of the item that will be ordered. Defaults to 1. (optional)
     * @param  string $order_line_forecast_promotion_choice_code (Optional) Promotion Choice that will be used on the order line. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetPriceAsyncWithHttpInfo($item_number, $price_code, $order_line_forecast_customer_number = null, $order_line_forecast_promotion_code = null, $order_line_forecast_billing_currency_code = null, $order_line_forecast_different_ship_to = null, $order_line_forecast_quantity = null, $order_line_forecast_promotion_choice_code = null)
    {
        $returnType = '\Advantage\Client\Model\ItemPrice';
        $request = $this->productGetPriceRequest($item_number, $price_code, $order_line_forecast_customer_number, $order_line_forecast_promotion_code, $order_line_forecast_billing_currency_code, $order_line_forecast_different_ship_to, $order_line_forecast_quantity, $order_line_forecast_promotion_choice_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetPrice'
     *
     * @param  string $item_number Item number to make an order off on. (required)
     * @param  string $price_code Optional price code to use for price calculation. (required)
     * @param  string $order_line_forecast_customer_number (Required) Customer Number of the customer that will be making the order. This customer  will serve as both the billing and ship to customer. (optional)
     * @param  string $order_line_forecast_promotion_code (Required) Promotion Code that will be used on the order line. (optional)
     * @param  string $order_line_forecast_billing_currency_code (Required) The currency that will be used on the order line. (optional)
     * @param  bool $order_line_forecast_different_ship_to (Optional) If true, the order forecaster will use a different customer as the ship to customer. (optional)
     * @param  int $order_line_forecast_quantity (Optional) The quantity of the item that will be ordered. Defaults to 1. (optional)
     * @param  string $order_line_forecast_promotion_choice_code (Optional) Promotion Choice that will be used on the order line. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetPriceRequest($item_number, $price_code, $order_line_forecast_customer_number = null, $order_line_forecast_promotion_code = null, $order_line_forecast_billing_currency_code = null, $order_line_forecast_different_ship_to = null, $order_line_forecast_quantity = null, $order_line_forecast_promotion_choice_code = null)
    {
        // verify the required parameter 'item_number' is set
        if ($item_number === null || (is_array($item_number) && count($item_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_number when calling productGetPrice'
            );
        }
        // verify the required parameter 'price_code' is set
        if ($price_code === null || (is_array($price_code) && count($price_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $price_code when calling productGetPrice'
            );
        }

        $resourcePath = '/products/{itemNumber}/price';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($price_code !== null) {
            $queryParams['priceCode'] = ObjectSerializer::toQueryValue($price_code);
        }
        // query params
        if ($order_line_forecast_customer_number !== null) {
            $queryParams['orderLineForecast.customerNumber'] = ObjectSerializer::toQueryValue($order_line_forecast_customer_number);
        }
        // query params
        if ($order_line_forecast_promotion_code !== null) {
            $queryParams['orderLineForecast.promotionCode'] = ObjectSerializer::toQueryValue($order_line_forecast_promotion_code);
        }
        // query params
        if ($order_line_forecast_billing_currency_code !== null) {
            $queryParams['orderLineForecast.billingCurrencyCode'] = ObjectSerializer::toQueryValue($order_line_forecast_billing_currency_code);
        }
        // query params
        if ($order_line_forecast_different_ship_to !== null) {
            $queryParams['orderLineForecast.differentShipTo'] = ObjectSerializer::toQueryValue($order_line_forecast_different_ship_to);
        }
        // query params
        if ($order_line_forecast_quantity !== null) {
            $queryParams['orderLineForecast.quantity'] = ObjectSerializer::toQueryValue($order_line_forecast_quantity);
        }
        // query params
        if ($order_line_forecast_promotion_choice_code !== null) {
            $queryParams['orderLineForecast.promotionChoiceCode'] = ObjectSerializer::toQueryValue($order_line_forecast_promotion_choice_code);
        }

        // path params
        if ($item_number !== null) {
            $resourcePath = str_replace(
                '{' . 'itemNumber' . '}',
                ObjectSerializer::toPathValue($item_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetProductContributions
     *
     * Get information for all products a customer is a contributor on.
     *
     * @param  string $customer_number The Advantage customer number to find products they contributed to (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultProductContribution
     */
    public function productGetProductContributions($customer_number)
    {
        list($response) = $this->productGetProductContributionsWithHttpInfo($customer_number);
        return $response;
    }

    /**
     * Operation productGetProductContributionsWithHttpInfo
     *
     * Get information for all products a customer is a contributor on.
     *
     * @param  string $customer_number The Advantage customer number to find products they contributed to (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultProductContribution, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetProductContributionsWithHttpInfo($customer_number)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProductContribution';
        $request = $this->productGetProductContributionsRequest($customer_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultProductContribution',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetProductContributionsAsync
     *
     * Get information for all products a customer is a contributor on.
     *
     * @param  string $customer_number The Advantage customer number to find products they contributed to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetProductContributionsAsync($customer_number)
    {
        return $this->productGetProductContributionsAsyncWithHttpInfo($customer_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetProductContributionsAsyncWithHttpInfo
     *
     * Get information for all products a customer is a contributor on.
     *
     * @param  string $customer_number The Advantage customer number to find products they contributed to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetProductContributionsAsyncWithHttpInfo($customer_number)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProductContribution';
        $request = $this->productGetProductContributionsRequest($customer_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetProductContributions'
     *
     * @param  string $customer_number The Advantage customer number to find products they contributed to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetProductContributionsRequest($customer_number)
    {
        // verify the required parameter 'customer_number' is set
        if ($customer_number === null || (is_array($customer_number) && count($customer_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_number when calling productGetProductContributions'
            );
        }

        $resourcePath = '/customers/{customerNumber}/product-contributions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($customer_number !== null) {
            $resourcePath = str_replace(
                '{' . 'customerNumber' . '}',
                ObjectSerializer::toPathValue($customer_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetPurchasedWith
     *
     * Get the item numbers of products purchased with given product.
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $days_of_history The number of days back (in history) to search. Starts with today. (required)
     * @param  int $threshold How many times must the products be purchased together to be included in the list? (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultProductSummary
     */
    public function productGetPurchasedWith($item_number, $days_of_history, $threshold, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->productGetPurchasedWithWithHttpInfo($item_number, $days_of_history, $threshold, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation productGetPurchasedWithWithHttpInfo
     *
     * Get the item numbers of products purchased with given product.
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $days_of_history The number of days back (in history) to search. Starts with today. (required)
     * @param  int $threshold How many times must the products be purchased together to be included in the list? (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultProductSummary, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetPurchasedWithWithHttpInfo($item_number, $days_of_history, $threshold, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProductSummary';
        $request = $this->productGetPurchasedWithRequest($item_number, $days_of_history, $threshold, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultProductSummary',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetPurchasedWithAsync
     *
     * Get the item numbers of products purchased with given product.
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $days_of_history The number of days back (in history) to search. Starts with today. (required)
     * @param  int $threshold How many times must the products be purchased together to be included in the list? (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetPurchasedWithAsync($item_number, $days_of_history, $threshold, $pager_skip = null, $pager_take = null)
    {
        return $this->productGetPurchasedWithAsyncWithHttpInfo($item_number, $days_of_history, $threshold, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetPurchasedWithAsyncWithHttpInfo
     *
     * Get the item numbers of products purchased with given product.
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $days_of_history The number of days back (in history) to search. Starts with today. (required)
     * @param  int $threshold How many times must the products be purchased together to be included in the list? (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetPurchasedWithAsyncWithHttpInfo($item_number, $days_of_history, $threshold, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProductSummary';
        $request = $this->productGetPurchasedWithRequest($item_number, $days_of_history, $threshold, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetPurchasedWith'
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $days_of_history The number of days back (in history) to search. Starts with today. (required)
     * @param  int $threshold How many times must the products be purchased together to be included in the list? (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetPurchasedWithRequest($item_number, $days_of_history, $threshold, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'item_number' is set
        if ($item_number === null || (is_array($item_number) && count($item_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_number when calling productGetPurchasedWith'
            );
        }
        // verify the required parameter 'days_of_history' is set
        if ($days_of_history === null || (is_array($days_of_history) && count($days_of_history) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $days_of_history when calling productGetPurchasedWith'
            );
        }
        // verify the required parameter 'threshold' is set
        if ($threshold === null || (is_array($threshold) && count($threshold) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $threshold when calling productGetPurchasedWith'
            );
        }

        $resourcePath = '/products/{itemNumber}/purchased-with-products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($days_of_history !== null) {
            $queryParams['daysOfHistory'] = ObjectSerializer::toQueryValue($days_of_history);
        }
        // query params
        if ($threshold !== null) {
            $queryParams['threshold'] = ObjectSerializer::toQueryValue($threshold);
        }
        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($item_number !== null) {
            $resourcePath = str_replace(
                '{' . 'itemNumber' . '}',
                ObjectSerializer::toPathValue($item_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productGetRelated
     *
     * Get the item numbers of products related to a given product.
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\SearchResultProductSummary
     */
    public function productGetRelated($item_number, $pager_skip = null, $pager_take = null)
    {
        list($response) = $this->productGetRelatedWithHttpInfo($item_number, $pager_skip, $pager_take);
        return $response;
    }

    /**
     * Operation productGetRelatedWithHttpInfo
     *
     * Get the item numbers of products related to a given product.
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\SearchResultProductSummary, HTTP status code, HTTP response headers (array of strings)
     */
    public function productGetRelatedWithHttpInfo($item_number, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProductSummary';
        $request = $this->productGetRelatedRequest($item_number, $pager_skip, $pager_take);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\SearchResultProductSummary',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productGetRelatedAsync
     *
     * Get the item numbers of products related to a given product.
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetRelatedAsync($item_number, $pager_skip = null, $pager_take = null)
    {
        return $this->productGetRelatedAsyncWithHttpInfo($item_number, $pager_skip, $pager_take)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productGetRelatedAsyncWithHttpInfo
     *
     * Get the item numbers of products related to a given product.
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productGetRelatedAsyncWithHttpInfo($item_number, $pager_skip = null, $pager_take = null)
    {
        $returnType = '\Advantage\Client\Model\SearchResultProductSummary';
        $request = $this->productGetRelatedRequest($item_number, $pager_skip, $pager_take);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productGetRelated'
     *
     * @param  string $item_number The item number of the product to use when finding related products. (required)
     * @param  int $pager_skip The number of records to skip. (optional)
     * @param  int $pager_take The number of records to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productGetRelatedRequest($item_number, $pager_skip = null, $pager_take = null)
    {
        // verify the required parameter 'item_number' is set
        if ($item_number === null || (is_array($item_number) && count($item_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_number when calling productGetRelated'
            );
        }

        $resourcePath = '/products/{itemNumber}/related-products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pager_skip !== null) {
            $queryParams['pager.skip'] = ObjectSerializer::toQueryValue($pager_skip);
        }
        // query params
        if ($pager_take !== null) {
            $queryParams['pager.take'] = ObjectSerializer::toQueryValue($pager_take);
        }

        // path params
        if ($item_number !== null) {
            $resourcePath = str_replace(
                '{' . 'itemNumber' . '}',
                ObjectSerializer::toPathValue($item_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productUpdate
     *
     * Update an existing product. This will update the name and narratives for products of any product type.  This will handle more complex changes for access, back issue, product, and subscription,  based on the populated values in the appropriate product request detail properties.
     *
     * @param  string $item_number The item number of the product to update (required)
     * @param  \Advantage\Client\Model\ProductUpdateRequest $product Information to update for the product (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productUpdate($item_number, $product)
    {
        $this->productUpdateWithHttpInfo($item_number, $product);
    }

    /**
     * Operation productUpdateWithHttpInfo
     *
     * Update an existing product. This will update the name and narratives for products of any product type.  This will handle more complex changes for access, back issue, product, and subscription,  based on the populated values in the appropriate product request detail properties.
     *
     * @param  string $item_number The item number of the product to update (required)
     * @param  \Advantage\Client\Model\ProductUpdateRequest $product Information to update for the product (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productUpdateWithHttpInfo($item_number, $product)
    {
        $returnType = '';
        $request = $this->productUpdateRequest($item_number, $product);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation productUpdateAsync
     *
     * Update an existing product. This will update the name and narratives for products of any product type.  This will handle more complex changes for access, back issue, product, and subscription,  based on the populated values in the appropriate product request detail properties.
     *
     * @param  string $item_number The item number of the product to update (required)
     * @param  \Advantage\Client\Model\ProductUpdateRequest $product Information to update for the product (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productUpdateAsync($item_number, $product)
    {
        return $this->productUpdateAsyncWithHttpInfo($item_number, $product)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productUpdateAsyncWithHttpInfo
     *
     * Update an existing product. This will update the name and narratives for products of any product type.  This will handle more complex changes for access, back issue, product, and subscription,  based on the populated values in the appropriate product request detail properties.
     *
     * @param  string $item_number The item number of the product to update (required)
     * @param  \Advantage\Client\Model\ProductUpdateRequest $product Information to update for the product (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productUpdateAsyncWithHttpInfo($item_number, $product)
    {
        $returnType = '';
        $request = $this->productUpdateRequest($item_number, $product);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productUpdate'
     *
     * @param  string $item_number The item number of the product to update (required)
     * @param  \Advantage\Client\Model\ProductUpdateRequest $product Information to update for the product (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productUpdateRequest($item_number, $product)
    {
        // verify the required parameter 'item_number' is set
        if ($item_number === null || (is_array($item_number) && count($item_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_number when calling productUpdate'
            );
        }
        // verify the required parameter 'product' is set
        if ($product === null || (is_array($product) && count($product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product when calling productUpdate'
            );
        }

        $resourcePath = '/products/{itemNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_number !== null) {
            $resourcePath = str_replace(
                '{' . 'itemNumber' . '}',
                ObjectSerializer::toPathValue($item_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($product)) {
            $_tempBody = $product;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
