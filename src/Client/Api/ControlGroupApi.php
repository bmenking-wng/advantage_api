<?php
/**
 * ControlGroupApi
 * PHP version 5
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Advantage.Rest.Services
 *
 * No description provided (generated by Advantage Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Advantage Codegen version: 2.4.20
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Advantage\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Advantage\Client\ApiException;
use Advantage\Client\Configuration;
use Advantage\Client\HeaderSelector;
use Advantage\Client\ObjectSerializer;

/**
 * ControlGroupApi Class Doc Comment
 *
 * @category Class
 * @package  Advantage\Client
 * @author   Advantage Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ControlGroupApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation controlGroupBalance
     *
     * Checks control totals to see if they match actual totals for the current control group.  An error is thrown if the control totals don't balance.  The MST120 process, which does  additional payment validation is also requested.  This process does its  validation asynchronously, but can be instructed to automatically release the control  group when it is finished.  A control group cannot be released until the control totals  balance and the payment validation has been passed.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupBalanceRequest $balance_request Balance Request Model (requestPaymentValidation and autoRelease) (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function controlGroupBalance($control_group_date, $control_group_code, $balance_request)
    {
        $this->controlGroupBalanceWithHttpInfo($control_group_date, $control_group_code, $balance_request);
    }

    /**
     * Operation controlGroupBalanceWithHttpInfo
     *
     * Checks control totals to see if they match actual totals for the current control group.  An error is thrown if the control totals don't balance.  The MST120 process, which does  additional payment validation is also requested.  This process does its  validation asynchronously, but can be instructed to automatically release the control  group when it is finished.  A control group cannot be released until the control totals  balance and the payment validation has been passed.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupBalanceRequest $balance_request Balance Request Model (requestPaymentValidation and autoRelease) (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupBalanceWithHttpInfo($control_group_date, $control_group_code, $balance_request)
    {
        $returnType = '';
        $request = $this->controlGroupBalanceRequest($control_group_date, $control_group_code, $balance_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupBalanceAsync
     *
     * Checks control totals to see if they match actual totals for the current control group.  An error is thrown if the control totals don't balance.  The MST120 process, which does  additional payment validation is also requested.  This process does its  validation asynchronously, but can be instructed to automatically release the control  group when it is finished.  A control group cannot be released until the control totals  balance and the payment validation has been passed.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupBalanceRequest $balance_request Balance Request Model (requestPaymentValidation and autoRelease) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupBalanceAsync($control_group_date, $control_group_code, $balance_request)
    {
        return $this->controlGroupBalanceAsyncWithHttpInfo($control_group_date, $control_group_code, $balance_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupBalanceAsyncWithHttpInfo
     *
     * Checks control totals to see if they match actual totals for the current control group.  An error is thrown if the control totals don't balance.  The MST120 process, which does  additional payment validation is also requested.  This process does its  validation asynchronously, but can be instructed to automatically release the control  group when it is finished.  A control group cannot be released until the control totals  balance and the payment validation has been passed.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupBalanceRequest $balance_request Balance Request Model (requestPaymentValidation and autoRelease) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupBalanceAsyncWithHttpInfo($control_group_date, $control_group_code, $balance_request)
    {
        $returnType = '';
        $request = $this->controlGroupBalanceRequest($control_group_date, $control_group_code, $balance_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupBalance'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupBalanceRequest $balance_request Balance Request Model (requestPaymentValidation and autoRelease) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupBalanceRequest($control_group_date, $control_group_code, $balance_request)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupBalance'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupBalance'
            );
        }
        // verify the required parameter 'balance_request' is set
        if ($balance_request === null || (is_array($balance_request) && count($balance_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $balance_request when calling controlGroupBalance'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($balance_request)) {
            $_tempBody = $balance_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupCloseControlGroup
     *
     * Closes a current control group preventing entry of orders into it.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function controlGroupCloseControlGroup($control_group_date, $control_group_code)
    {
        $this->controlGroupCloseControlGroupWithHttpInfo($control_group_date, $control_group_code);
    }

    /**
     * Operation controlGroupCloseControlGroupWithHttpInfo
     *
     * Closes a current control group preventing entry of orders into it.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupCloseControlGroupWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '';
        $request = $this->controlGroupCloseControlGroupRequest($control_group_date, $control_group_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupCloseControlGroupAsync
     *
     * Closes a current control group preventing entry of orders into it.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupCloseControlGroupAsync($control_group_date, $control_group_code)
    {
        return $this->controlGroupCloseControlGroupAsyncWithHttpInfo($control_group_date, $control_group_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupCloseControlGroupAsyncWithHttpInfo
     *
     * Closes a current control group preventing entry of orders into it.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupCloseControlGroupAsyncWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '';
        $request = $this->controlGroupCloseControlGroupRequest($control_group_date, $control_group_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupCloseControlGroup'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupCloseControlGroupRequest($control_group_date, $control_group_code)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupCloseControlGroup'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupCloseControlGroup'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}/close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupCreateOrUpdate
     *
     * Create or Update a Control Group from a ControlGroupIn Model
     *
     * @param  \Advantage\Client\Model\ControlGroupIn $control_group_in Model to Create/Update Control Group (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\ControlGroup
     */
    public function controlGroupCreateOrUpdate($control_group_in)
    {
        list($response) = $this->controlGroupCreateOrUpdateWithHttpInfo($control_group_in);
        return $response;
    }

    /**
     * Operation controlGroupCreateOrUpdateWithHttpInfo
     *
     * Create or Update a Control Group from a ControlGroupIn Model
     *
     * @param  \Advantage\Client\Model\ControlGroupIn $control_group_in Model to Create/Update Control Group (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\ControlGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupCreateOrUpdateWithHttpInfo($control_group_in)
    {
        $returnType = '\Advantage\Client\Model\ControlGroup';
        $request = $this->controlGroupCreateOrUpdateRequest($control_group_in);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\ControlGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupCreateOrUpdateAsync
     *
     * Create or Update a Control Group from a ControlGroupIn Model
     *
     * @param  \Advantage\Client\Model\ControlGroupIn $control_group_in Model to Create/Update Control Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupCreateOrUpdateAsync($control_group_in)
    {
        return $this->controlGroupCreateOrUpdateAsyncWithHttpInfo($control_group_in)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupCreateOrUpdateAsyncWithHttpInfo
     *
     * Create or Update a Control Group from a ControlGroupIn Model
     *
     * @param  \Advantage\Client\Model\ControlGroupIn $control_group_in Model to Create/Update Control Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupCreateOrUpdateAsyncWithHttpInfo($control_group_in)
    {
        $returnType = '\Advantage\Client\Model\ControlGroup';
        $request = $this->controlGroupCreateOrUpdateRequest($control_group_in);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupCreateOrUpdate'
     *
     * @param  \Advantage\Client\Model\ControlGroupIn $control_group_in Model to Create/Update Control Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupCreateOrUpdateRequest($control_group_in)
    {
        // verify the required parameter 'control_group_in' is set
        if ($control_group_in === null || (is_array($control_group_in) && count($control_group_in) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_in when calling controlGroupCreateOrUpdate'
            );
        }

        $resourcePath = '/control-groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($control_group_in)) {
            $_tempBody = $control_group_in;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupGet
     *
     * Gets a Control Group base on Date and ID
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\ControlGroup
     */
    public function controlGroupGet($control_group_date, $control_group_code)
    {
        list($response) = $this->controlGroupGetWithHttpInfo($control_group_date, $control_group_code);
        return $response;
    }

    /**
     * Operation controlGroupGetWithHttpInfo
     *
     * Gets a Control Group base on Date and ID
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\ControlGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupGetWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '\Advantage\Client\Model\ControlGroup';
        $request = $this->controlGroupGetRequest($control_group_date, $control_group_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\ControlGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupGetAsync
     *
     * Gets a Control Group base on Date and ID
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupGetAsync($control_group_date, $control_group_code)
    {
        return $this->controlGroupGetAsyncWithHttpInfo($control_group_date, $control_group_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupGetAsyncWithHttpInfo
     *
     * Gets a Control Group base on Date and ID
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupGetAsyncWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '\Advantage\Client\Model\ControlGroup';
        $request = $this->controlGroupGetRequest($control_group_date, $control_group_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupGet'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupGetRequest($control_group_date, $control_group_code)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupGet'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupGet'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupOpen
     *
     * Opens a control group enabling entry of orders into it.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function controlGroupOpen($control_group_date, $control_group_code)
    {
        $this->controlGroupOpenWithHttpInfo($control_group_date, $control_group_code);
    }

    /**
     * Operation controlGroupOpenWithHttpInfo
     *
     * Opens a control group enabling entry of orders into it.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupOpenWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '';
        $request = $this->controlGroupOpenRequest($control_group_date, $control_group_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupOpenAsync
     *
     * Opens a control group enabling entry of orders into it.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupOpenAsync($control_group_date, $control_group_code)
    {
        return $this->controlGroupOpenAsyncWithHttpInfo($control_group_date, $control_group_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupOpenAsyncWithHttpInfo
     *
     * Opens a control group enabling entry of orders into it.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupOpenAsyncWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '';
        $request = $this->controlGroupOpenRequest($control_group_date, $control_group_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupOpen'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupOpenRequest($control_group_date, $control_group_code)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupOpen'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupOpen'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}/open';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupPurge
     *
     * Requests the MST830 process to delete all unposted orders in the current control group.  This process deletes the orders asynchronously.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupPurgeRequest $purge_offline_request True to delete the control group after purging orders (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function controlGroupPurge($control_group_date, $control_group_code, $purge_offline_request)
    {
        $this->controlGroupPurgeWithHttpInfo($control_group_date, $control_group_code, $purge_offline_request);
    }

    /**
     * Operation controlGroupPurgeWithHttpInfo
     *
     * Requests the MST830 process to delete all unposted orders in the current control group.  This process deletes the orders asynchronously.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupPurgeRequest $purge_offline_request True to delete the control group after purging orders (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupPurgeWithHttpInfo($control_group_date, $control_group_code, $purge_offline_request)
    {
        $returnType = '';
        $request = $this->controlGroupPurgeRequest($control_group_date, $control_group_code, $purge_offline_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupPurgeAsync
     *
     * Requests the MST830 process to delete all unposted orders in the current control group.  This process deletes the orders asynchronously.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupPurgeRequest $purge_offline_request True to delete the control group after purging orders (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupPurgeAsync($control_group_date, $control_group_code, $purge_offline_request)
    {
        return $this->controlGroupPurgeAsyncWithHttpInfo($control_group_date, $control_group_code, $purge_offline_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupPurgeAsyncWithHttpInfo
     *
     * Requests the MST830 process to delete all unposted orders in the current control group.  This process deletes the orders asynchronously.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupPurgeRequest $purge_offline_request True to delete the control group after purging orders (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupPurgeAsyncWithHttpInfo($control_group_date, $control_group_code, $purge_offline_request)
    {
        $returnType = '';
        $request = $this->controlGroupPurgeRequest($control_group_date, $control_group_code, $purge_offline_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupPurge'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupPurgeRequest $purge_offline_request True to delete the control group after purging orders (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupPurgeRequest($control_group_date, $control_group_code, $purge_offline_request)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupPurge'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupPurge'
            );
        }
        // verify the required parameter 'purge_offline_request' is set
        if ($purge_offline_request === null || (is_array($purge_offline_request) && count($purge_offline_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purge_offline_request when calling controlGroupPurge'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}/purge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($purge_offline_request)) {
            $_tempBody = $purge_offline_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupRelease
     *
     * Releases a current control group.  A control group must be closed and balanced before  it can be released.  Releasing a control group indicates that all orders  in the control group are done and ready to be posted.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function controlGroupRelease($control_group_date, $control_group_code)
    {
        $this->controlGroupReleaseWithHttpInfo($control_group_date, $control_group_code);
    }

    /**
     * Operation controlGroupReleaseWithHttpInfo
     *
     * Releases a current control group.  A control group must be closed and balanced before  it can be released.  Releasing a control group indicates that all orders  in the control group are done and ready to be posted.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupReleaseWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '';
        $request = $this->controlGroupReleaseRequest($control_group_date, $control_group_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupReleaseAsync
     *
     * Releases a current control group.  A control group must be closed and balanced before  it can be released.  Releasing a control group indicates that all orders  in the control group are done and ready to be posted.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupReleaseAsync($control_group_date, $control_group_code)
    {
        return $this->controlGroupReleaseAsyncWithHttpInfo($control_group_date, $control_group_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupReleaseAsyncWithHttpInfo
     *
     * Releases a current control group.  A control group must be closed and balanced before  it can be released.  Releasing a control group indicates that all orders  in the control group are done and ready to be posted.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupReleaseAsyncWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '';
        $request = $this->controlGroupReleaseRequest($control_group_date, $control_group_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupRelease'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupReleaseRequest($control_group_date, $control_group_code)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupRelease'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupRelease'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupRemove
     *
     * Removes a Control Group
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function controlGroupRemove($control_group_date, $control_group_code)
    {
        $this->controlGroupRemoveWithHttpInfo($control_group_date, $control_group_code);
    }

    /**
     * Operation controlGroupRemoveWithHttpInfo
     *
     * Removes a Control Group
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupRemoveWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '';
        $request = $this->controlGroupRemoveRequest($control_group_date, $control_group_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupRemoveAsync
     *
     * Removes a Control Group
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupRemoveAsync($control_group_date, $control_group_code)
    {
        return $this->controlGroupRemoveAsyncWithHttpInfo($control_group_date, $control_group_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupRemoveAsyncWithHttpInfo
     *
     * Removes a Control Group
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupRemoveAsyncWithHttpInfo($control_group_date, $control_group_code)
    {
        $returnType = '';
        $request = $this->controlGroupRemoveRequest($control_group_date, $control_group_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupRemove'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupRemoveRequest($control_group_date, $control_group_code)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupRemove'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupRemove'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupUnrelease
     *
     * Un-releases the current control group indicating that its orders are not yet ready  to be posted.  A control group cannot be unreleased if any of its orders have been posted.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUnreleaseRequest $unrelease_request The ARP user ID to recreate the ARP control group;              WWWEB is used by default (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function controlGroupUnrelease($control_group_date, $control_group_code, $unrelease_request)
    {
        $this->controlGroupUnreleaseWithHttpInfo($control_group_date, $control_group_code, $unrelease_request);
    }

    /**
     * Operation controlGroupUnreleaseWithHttpInfo
     *
     * Un-releases the current control group indicating that its orders are not yet ready  to be posted.  A control group cannot be unreleased if any of its orders have been posted.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUnreleaseRequest $unrelease_request The ARP user ID to recreate the ARP control group;              WWWEB is used by default (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupUnreleaseWithHttpInfo($control_group_date, $control_group_code, $unrelease_request)
    {
        $returnType = '';
        $request = $this->controlGroupUnreleaseRequest($control_group_date, $control_group_code, $unrelease_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupUnreleaseAsync
     *
     * Un-releases the current control group indicating that its orders are not yet ready  to be posted.  A control group cannot be unreleased if any of its orders have been posted.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUnreleaseRequest $unrelease_request The ARP user ID to recreate the ARP control group;              WWWEB is used by default (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupUnreleaseAsync($control_group_date, $control_group_code, $unrelease_request)
    {
        return $this->controlGroupUnreleaseAsyncWithHttpInfo($control_group_date, $control_group_code, $unrelease_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupUnreleaseAsyncWithHttpInfo
     *
     * Un-releases the current control group indicating that its orders are not yet ready  to be posted.  A control group cannot be unreleased if any of its orders have been posted.
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUnreleaseRequest $unrelease_request The ARP user ID to recreate the ARP control group;              WWWEB is used by default (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupUnreleaseAsyncWithHttpInfo($control_group_date, $control_group_code, $unrelease_request)
    {
        $returnType = '';
        $request = $this->controlGroupUnreleaseRequest($control_group_date, $control_group_code, $unrelease_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupUnrelease'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUnreleaseRequest $unrelease_request The ARP user ID to recreate the ARP control group;              WWWEB is used by default (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupUnreleaseRequest($control_group_date, $control_group_code, $unrelease_request)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupUnrelease'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupUnrelease'
            );
        }
        // verify the required parameter 'unrelease_request' is set
        if ($unrelease_request === null || (is_array($unrelease_request) && count($unrelease_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unrelease_request when calling controlGroupUnrelease'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}/unrelease';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($unrelease_request)) {
            $_tempBody = $unrelease_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation controlGroupUpdate
     *
     * Update a Control Group from a ControlGroupUpdateRequest Model
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUpdateRequest $control_group_update_request Model to Update Control Group (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Advantage\Client\Model\ControlGroup
     */
    public function controlGroupUpdate($control_group_date, $control_group_code, $control_group_update_request)
    {
        list($response) = $this->controlGroupUpdateWithHttpInfo($control_group_date, $control_group_code, $control_group_update_request);
        return $response;
    }

    /**
     * Operation controlGroupUpdateWithHttpInfo
     *
     * Update a Control Group from a ControlGroupUpdateRequest Model
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUpdateRequest $control_group_update_request Model to Update Control Group (required)
     *
     * @throws \Advantage\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Advantage\Client\Model\ControlGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function controlGroupUpdateWithHttpInfo($control_group_date, $control_group_code, $control_group_update_request)
    {
        $returnType = '\Advantage\Client\Model\ControlGroup';
        $request = $this->controlGroupUpdateRequest($control_group_date, $control_group_code, $control_group_update_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Advantage\Client\Model\ControlGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation controlGroupUpdateAsync
     *
     * Update a Control Group from a ControlGroupUpdateRequest Model
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUpdateRequest $control_group_update_request Model to Update Control Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupUpdateAsync($control_group_date, $control_group_code, $control_group_update_request)
    {
        return $this->controlGroupUpdateAsyncWithHttpInfo($control_group_date, $control_group_code, $control_group_update_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation controlGroupUpdateAsyncWithHttpInfo
     *
     * Update a Control Group from a ControlGroupUpdateRequest Model
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUpdateRequest $control_group_update_request Model to Update Control Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function controlGroupUpdateAsyncWithHttpInfo($control_group_date, $control_group_code, $control_group_update_request)
    {
        $returnType = '\Advantage\Client\Model\ControlGroup';
        $request = $this->controlGroupUpdateRequest($control_group_date, $control_group_code, $control_group_update_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'controlGroupUpdate'
     *
     * @param  \DateTime $control_group_date Control Group Date (required)
     * @param  string $control_group_code Control Group ID (required)
     * @param  \Advantage\Client\Model\ControlGroupUpdateRequest $control_group_update_request Model to Update Control Group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function controlGroupUpdateRequest($control_group_date, $control_group_code, $control_group_update_request)
    {
        // verify the required parameter 'control_group_date' is set
        if ($control_group_date === null || (is_array($control_group_date) && count($control_group_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_date when calling controlGroupUpdate'
            );
        }
        // verify the required parameter 'control_group_code' is set
        if ($control_group_code === null || (is_array($control_group_code) && count($control_group_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_code when calling controlGroupUpdate'
            );
        }
        // verify the required parameter 'control_group_update_request' is set
        if ($control_group_update_request === null || (is_array($control_group_update_request) && count($control_group_update_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $control_group_update_request when calling controlGroupUpdate'
            );
        }

        $resourcePath = '/control-groups/{controlGroupDate}/{controlGroupCode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($control_group_date !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupDate' . '}',
                ObjectSerializer::toPathValue($control_group_date),
                $resourcePath
            );
        }
        // path params
        if ($control_group_code !== null) {
            $resourcePath = str_replace(
                '{' . 'controlGroupCode' . '}',
                ObjectSerializer::toPathValue($control_group_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($control_group_update_request)) {
            $_tempBody = $control_group_update_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'text/html'],
                ['application/json', 'text/json', 'text/html', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
